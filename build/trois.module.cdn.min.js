import{watch as d,toRef as Ge,ref as qr,defineComponent as o,inject as V,provide as Yr,getCurrentInstance as Jr,onUnmounted as Qr,createApp as es}from"https://unpkg.com/vue@3.2.20/dist/vue.esm-browser.prod.js";import{Vector3 as ie,Raycaster as ts,Plane as rs,Vector2 as A,InstancedMesh as ye,WebGLRenderer as ss,OrthographicCamera as is,PerspectiveCamera as ns,Scene as as,Color as K,Texture as os,Group as hs,WebGLCubeRenderTarget as ds,RGBFormat as cs,LinearMipmapLinearFilter as ls,CubeCamera as us,Mesh as ms,BufferGeometry as fs,BufferAttribute as ps,BoxGeometry as je,CircleGeometry as ys,ConeGeometry as gs,CylinderGeometry as vs,DodecahedronGeometry as bs,ExtrudeGeometry as Ss,IcosahedronGeometry as Ps,LatheGeometry as xs,OctahedronGeometry as ws,PlaneGeometry as ke,PolyhedronGeometry as Cs,RingGeometry as Ms,SphereGeometry as Ls,ShapeGeometry as Gs,TetrahedronGeometry as js,TorusGeometry as ks,TorusKnotGeometry as Os,TubeGeometry as _s,CatmullRomCurve3 as Oe,Curve as Ns,SpotLight as ge,DirectionalLight as ve,AmbientLight as Es,HemisphereLight as Rs,PointLight as $s,RectAreaLight as zs,MeshLambertMaterial as Ts,MeshPhongMaterial as As,MeshPhysicalMaterial as Is,PointsMaterial as Bs,ShadowMaterial as Fs,MeshStandardMaterial as Ds,MeshToonMaterial as Us,MeshBasicMaterial as _e,TextureLoader as J,MeshMatcapMaterial as Hs,ShaderMaterial as be,ShaderChunk as X,UniformsUtils as Ne,ShaderLib as Vs,CubeReflectionMapping as Ks,CubeTextureLoader as Xs,VideoTexture as Ws,DoubleSide as Zs,SpriteMaterial as qs,Sprite as Ys,Points as Js}from"https://cdn.skypack.dev/three@0.134.0/build/three.module.js";import{OrbitControls as Qs}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/controls/OrbitControls.js";import{RectAreaLightUniformsLib as ei}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as ti}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/helpers/RectAreaLightHelper.js";import{TextGeometry as ri}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/geometries/TextGeometry.js";import{FontLoader as si}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/FontLoader.js";import{GLTFLoader as ii}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as ni}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as ai}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as oi}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as hi}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as di}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as ne}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as ci}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as li}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as ui}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as mi}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as fi}from"https://cdn.skypack.dev/three@0.134.0/examples/jsm/postprocessing/UnrealBloomPass.js";function W(e,t,r){t instanceof Object&&Object.entries(t).forEach(([s,i])=>{r?r(e,s,i):e[s]=i})}function I(e,t,r,s=!0,i){s&&W(r,e[t],i);const a=Ge(e,t);return d(a,n=>{W(r,n,i)})}function Ee(e,t,r=!0,s){r&&W(t,e,s);const i=qr(e);return d(i,a=>{W(t,a,s)},{deep:!0})}function Z(e,t){t instanceof Object&&Object.entries(t).forEach(([r,s])=>{e[r]=s})}function Re(e,t,r){t.forEach(s=>{f(e,s,r,s)})}function f(e,t,r,s){const i=s||t,a=Ge(e,t);a.value instanceof Object?(Z(r[i],a.value),d(a,n=>{Z(r[i],n)},{deep:!0})):(a.value!==void 0&&(r[i]=e[t]),d(a,n=>{r[i]=n}))}function Q(e,t=[]){const r={};return Object.entries(e).forEach(([s,i])=>{(!t||!t.includes(s))&&(r[s]=i)}),r}function $e(e,t,r){return r=r<0?0:r,r=r>1?1:r,e+(t-e)*r}function ze(e,t,r){return e<t?t:e>r?r:e}const pi="https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d",yi="0404E8_0404B5_0404CB_3333FC";function Se(e=yi,t=1024){const r=`${e}${gi(t)}.png`;return`${pi}/${t}/${r}`}function gi(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}function vi(e){const{camera:t,resetPosition:r=new ie(0,0,0)}=e,s=new ts,i=r.clone(),a=new rs(new ie(0,0,1),0);return{position:i,updatePosition:M=>{s.setFromCamera(M,t),t.getWorldDirection(a.normal),s.ray.intersectPlane(a,i)},intersect:(M,L,m=!1)=>(s.setFromCamera(M,t),s.intersectObjects(L,m))}}function Te(e){const{camera:t,domElement:r,intersectObjects:s,intersectRecursive:i=!1,touch:a=!0,resetOnEnd:n=!1,onEnter:l=()=>{},onMove:M=()=>{},onLeave:L=()=>{},onClick:m=()=>{},onIntersectEnter:j=()=>{},onIntersectOver:_=()=>{},onIntersectMove:v=()=>{},onIntersectLeave:D=()=>{},onIntersectClick:U=()=>{}}=e,p=new A(0,0),y=new A(0,0),N=vi({camera:t}),h=N.position,c={position:p,positionN:y,positionV3:h,intersectObjects:s,listeners:!1,addListeners:Wr,removeListeners:Zr,intersect:xe};return c;function k(){p.set(0,0),y.set(0,0),h.set(0,0,0)}function b(u){let x,T;u.touches&&u.touches.length>0?(x=u.touches[0].clientX,T=u.touches[0].clientY):(x=u.clientX,T=u.clientY);const E=r.getBoundingClientRect();p.x=x-E.left,p.y=T-E.top,y.x=p.x/E.width*2-1,y.y=-(p.y/E.height)*2+1,N.updatePosition(y)}function xe(){const u=Ce();if(u.length){const x=N.intersect(y,u,i),T=[...u],E=[];x.forEach(R=>{var F,$,S;const{object:w}=R,C=fe(w);if(w instanceof ye){if(E.indexOf(w)!==-1)return;E.push(w)}if(!w.userData.over){w.userData.over=!0;const pe={type:"pointerover",over:!0,component:C,intersect:R},Le={...pe,type:"pointerenter"};_(pe),j(Le),(F=C==null?void 0:C.onPointerOver)==null||F.call(C,pe),($=C==null?void 0:C.onPointerEnter)==null||$.call(C,Le)}const Me={type:"pointermove",component:C,intersect:R};v(Me),(S=C==null?void 0:C.onPointerMove)==null||S.call(C,Me),T.splice(T.indexOf(w),1)}),T.forEach(R=>{var F,$;const S=fe(R);if(R.userData.over){R.userData.over=!1;const w={type:"pointerover",over:!1,component:S},C={...w,type:"pointerleave"};_(w),D(C),(F=S==null?void 0:S.onPointerOver)==null||F.call(S,w),($=S==null?void 0:S.onPointerLeave)==null||$.call(S,C)}})}}function te(u){b(u),l({type:"pointerenter",position:p,positionN:y,positionV3:h})}function re(u){b(u),M({type:"pointermove",position:p,positionN:y,positionV3:h}),xe()}function we(u){b(u);const x=Ce();if(x.length){const T=N.intersect(y,x,i),E=[];T.forEach(R=>{var F;const{object:$}=R,S=fe($);if($ instanceof ye){if(E.indexOf($)!==-1)return;E.push($)}const w={type:"click",component:S,intersect:R};U(w),(F=S==null?void 0:S.onClick)==null||F.call(S,w)})}m({type:"click",position:p,positionN:y,positionV3:h})}function se(){n&&k(),L({type:"pointerleave"})}function fe(u){if(u.userData.component)return u.userData.component;let x=u.parent;for(;x;){if(x.userData.component)return x.userData.component;x=x.parent}}function Ce(){return typeof s=="function"?s():s}function Wr(){r.addEventListener("mouseenter",te),r.addEventListener("mousemove",re),r.addEventListener("mouseleave",se),r.addEventListener("click",we),a&&(r.addEventListener("touchstart",te),r.addEventListener("touchmove",re),r.addEventListener("touchend",se)),c.listeners=!0}function Zr(){r.removeEventListener("mouseenter",te),r.removeEventListener("mousemove",re),r.removeEventListener("mouseleave",se),r.removeEventListener("click",we),r.removeEventListener("touchstart",te),r.removeEventListener("touchmove",re),r.removeEventListener("touchend",se),c.listeners=!1}}function bi(e){const t={antialias:!0,alpha:!1,autoClear:!0,orbitCtrl:!1,pointer:!1,resize:!1,width:300,height:150};e&&Object.entries(e).forEach(([h,c])=>{t[h]=c});const r={width:1,height:1,wWidth:1,wHeight:1,ratio:1},s=[],i=[],a=l(),n={config:t,renderer:a,size:r,init:M,dispose:U,render:j,renderC:_,setSize:y,addIntersectObject:v,removeIntersectObject:D};return n;function l(){const h=new ss({canvas:t.canvas,antialias:t.antialias,alpha:t.alpha,...t.params});return h.autoClear=t.autoClear,h}function M(){if(!n.scene)return console.error("Missing Scene"),!1;if(!n.camera)return console.error("Missing Camera"),!1;if(t.resize?(p(),window.addEventListener("resize",p)):t.width&&t.height&&y(t.width,t.height),L(),t.orbitCtrl){const h=new Qs(n.camera,n.renderer.domElement);t.orbitCtrl instanceof Object&&Object.entries(t.orbitCtrl).forEach(([c,k])=>{h[c]=k}),m(()=>{h.update()}),n.cameraCtrl=h}return!0}function L(){let h={camera:n.camera,domElement:n.renderer.domElement,intersectObjects:i};t.pointer&&t.pointer instanceof Object&&(h={...h,...t.pointer});const c=n.pointer=Te(h);(t.pointer||i.length)&&(c.addListeners(),h.intersectMode==="frame"&&m(c.intersect))}function m(h){s.push(h)}function j(){s.forEach(h=>h()),n.renderer.render(n.scene,n.camera)}function _(){s.forEach(h=>h()),n.composer.render()}function v(h){i.indexOf(h)===-1&&i.push(h),n.pointer&&!n.pointer.listeners&&n.pointer.addListeners()}function D(h){const c=i.indexOf(h);c!==-1&&i.splice(c,1),n.pointer&&!t.pointer&&i.length===0&&n.pointer.removeListeners()}function U(){window.removeEventListener("resize",p),n.pointer&&n.pointer.removeListeners(),n.cameraCtrl&&n.cameraCtrl.dispose(),n.renderer&&n.renderer.dispose()}function p(){var h;if(t.resize==="window")y(window.innerWidth,window.innerHeight);else{const c=n.renderer.domElement.parentNode;c&&y(c.clientWidth,c.clientHeight)}(h=t.onResize)==null||h.call(t,r)}function y(h,c){r.width=h,r.height=c,r.ratio=h/c,n.renderer.setSize(h,c,!1);const k=n.camera;if(k.type==="PerspectiveCamera"){const b=k;b.aspect=r.ratio,b.updateProjectionMatrix()}if(k.type==="OrthographicCamera"){const b=k;r.wWidth=b.right-b.left,r.wHeight=b.top-b.bottom}else{const b=N();r.wWidth=b[0],r.wHeight=b[1]}}function N(){const h=n.camera,c=h.fov*Math.PI/180,k=2*Math.tan(c/2)*Math.abs(h.position.z);return[k*h.aspect,k]}}const O=Symbol("Renderer");var Ae=o({name:"Renderer",props:{params:{type:Object,default:()=>({})},antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,width:String,height:String,xr:Boolean,props:{type:Object,default:()=>({})},onReady:Function},inheritAttrs:!1,setup(e,{attrs:t}){const r=[],s=[],i=[],a=[],n=[],l=document.createElement("canvas");Object.entries(t).forEach(([j,_])=>{const v=j.match(/^on([A-Z][a-zA-Z]*)$/);v?l.addEventListener(v[1].toLowerCase(),_):l.setAttribute(j,_)});const M={canvas:l,params:e.params,antialias:e.antialias,alpha:e.alpha,autoClear:e.autoClear,orbitCtrl:e.orbitCtrl,pointer:e.pointer,resize:e.resize};e.width&&(M.width=parseInt(e.width)),e.height&&(M.height=parseInt(e.height));const L=bi(M);I(e,"props",L.renderer);const m=()=>{};return{canvas:l,three:L,renderer:L.renderer,size:L.size,renderFn:m,raf:!0,initCallbacks:r,mountedCallbacks:s,beforeRenderCallbacks:i,afterRenderCallbacks:a,resizeCallbacks:n}},computed:{camera:{get:function(){return this.three.camera},set:function(e){this.three.camera=e}},scene:{get:function(){return this.three.scene},set:function(e){this.three.scene=e}},composer:{get:function(){return this.three.composer},set:function(e){this.three.composer=e}}},provide(){return{[O]:this}},mounted(){var e;this.$el.parentNode.insertBefore(this.canvas,this.$el),this.three.init()&&(this.three.pointer&&(this.$pointer=this.three.pointer),this.three.config.onResize=t=>{this.resizeCallbacks.forEach(r=>r({type:"resize",renderer:this,size:t}))},this.shadow&&(this.renderer.shadowMap.enabled=!0),this.renderFn=this.three.composer?this.three.renderC:this.three.render,this.initCallbacks.forEach(t=>t({type:"init",renderer:this})),(e=this.onReady)==null||e.call(this,this),this.xr?(this.renderer.xr.enabled=!0,this.renderer.setAnimationLoop(this.render)):requestAnimationFrame(this.renderLoop)),this.mountedCallbacks.forEach(t=>t({type:"mounted",renderer:this}))},beforeUnmount(){this.canvas.remove(),this.beforeRenderCallbacks=[],this.afterRenderCallbacks=[],this.raf=!1,this.three.dispose()},methods:{onInit(e){this.addListener("init",e)},onMounted(e){this.addListener("mounted",e)},onBeforeRender(e){this.addListener("beforerender",e)},offBeforeRender(e){this.removeListener("beforerender",e)},onAfterRender(e){this.addListener("afterrender",e)},offAfterRender(e){this.removeListener("afterrender",e)},onResize(e){this.addListener("resize",e)},offResize(e){this.removeListener("resize",e)},addListener(e,t){this.getCallbacks(e).push(t)},removeListener(e,t){const r=this.getCallbacks(e),s=r.indexOf(t);s!==-1&&r.splice(s,1)},getCallbacks(e){return e==="init"?this.initCallbacks:e==="mounted"?this.mountedCallbacks:e==="beforerender"?this.beforeRenderCallbacks:e==="afterrender"?this.afterRenderCallbacks:this.resizeCallbacks},render(e){this.beforeRenderCallbacks.forEach(t=>t({type:"beforerender",renderer:this,time:e})),this.renderFn({renderer:this,time:e}),this.afterRenderCallbacks.forEach(t=>t({type:"afterrender",renderer:this,time:e}))},renderLoop(e){this.raf&&requestAnimationFrame(this.renderLoop),this.render(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Renderer"}),Ie=o({props:{props:{type:Object,default:()=>({})}},render(){return this.$slots.default?this.$slots.default():[]}});function ae(e,t,r,s=!0){e[t]=r,s&&e.updateProjectionMatrix()}var Be=o({extends:Ie,name:"OrthographicCamera",props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:()=>({x:0,y:0,z:0})}},setup(e){const t=V(O);if(!t){console.error("Renderer not found");return}const r=new is(e.left,e.right,e.top,e.bottom,e.near,e.far);return t.camera=r,f(e,"position",r),I(e,"props",r,!0,ae),["left","right","top","bottom","near","far","zoom"].forEach(s=>{d(()=>e[s],i=>{ae(r,s,i)})}),{renderer:t,camera:r}},__hmrId:"OrthographicCamera"}),oe=o({extends:Ie,name:"PerspectiveCamera",props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:()=>({x:0,y:0,z:0})},lookAt:{type:Object,default:null}},setup(e){var t;const r=V(O);if(!r){console.error("Renderer not found");return}const s=new ns(e.fov,e.aspect,e.near,e.far);return r.camera=s,f(e,"position",s),e.lookAt&&s.lookAt((t=e.lookAt.x)!=null?t:0,e.lookAt.y,e.lookAt.z),d(()=>e.lookAt,i=>{var a;s.lookAt((a=i.x)!=null?a:0,i.y,i.z)},{deep:!0}),I(e,"props",s,!0,ae),["aspect","far","fov","near"].forEach(i=>{d(()=>e[i],a=>{ae(s,i,a)})}),{renderer:r,camera:s}},__hmrId:"PerspectiveCamera"});const he=Symbol("Scene");var Fe=o({name:"Scene",props:{background:[String,Number,Object]},setup(e){const t=V(O),r=new as;if(!t){console.error("Renderer not found");return}t.scene=r,Yr(he,r);const s=n=>{!n||(typeof n=="string"||typeof n=="number"?r.background instanceof K?r.background.set(n):r.background=new K(n):(n instanceof os||n instanceof K)&&(r.background=n))};return s(e.background),d(()=>e.background,s),{scene:r,add:n=>{r.add(n)},remove:n=>{r.remove(n)}}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"});const Si={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function};var B=o({name:"Object3D",inject:{renderer:O,scene:he},emits:["created","ready"],props:{position:{type:Object,default:()=>({x:0,y:0,z:0})},rotation:{type:Object,default:()=>({x:0,y:0,z:0})},scale:{type:Object,default:()=>({x:1,y:1,z:1,order:"XYZ"})},lookAt:{type:Object,default:null},userData:{type:Object,default:()=>({})},visible:{type:Boolean,default:!0},props:{type:Object,default:()=>({})},disableAdd:{type:Boolean,default:!1},disableRemove:{type:Boolean,default:!1},...Si},setup(){return{}},created(){this.renderer||console.error("Missing parent Renderer"),this.scene||console.error("Missing parent Scene")},unmounted(){this.disableRemove||this.removeFromParent(),this.o3d&&this.renderer&&this.renderer.three.removeIntersectObject(this.o3d)},methods:{initObject3D(e){var t;this.o3d=e,e.userData.component=this,(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer&&this.renderer.three.addIntersectObject(e),f(this,"position",e),f(this,"rotation",e),f(this,"scale",e),f(this,"userData",e.userData),f(this,"visible",e),I(this,"props",e),this.$emit("created",e),this.lookAt&&e.lookAt((t=this.lookAt.x)!=null?t:0,this.lookAt.y,this.lookAt.z),d(()=>this.lookAt,r=>{var s;e.lookAt((s=r.x)!=null?s:0,r.y,r.z)},{deep:!0}),this.parent=this.getParent(),this.disableAdd||(this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)"))},getParent(){let e=this.$parent;if(!e){const t=Jr();t&&t.parent&&(e=t.parent.ctx)}for(;e;){if(e.add)return e;e=e.$parent}},addToParent(e){const t=e||this.o3d;return this.parent?(this.parent.add(t),!0):!1},removeFromParent(e){const t=e||this.o3d;return this.parent?(this.parent.remove(t),!0):!1},add(e){var t;(t=this.o3d)==null||t.add(e)},remove(e){var t;(t=this.o3d)==null||t.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),De=o({name:"Group",extends:B,setup(){return{group:new hs}},created(){this.initObject3D(this.group)},__hmrId:"Group"});const ee=()=>{};var Ue=o({name:"Raycaster",props:{onPointerEnter:{type:Function,default:ee},onPointerOver:{type:Function,default:ee},onPointerMove:{type:Function,default:ee},onPointerLeave:{type:Function,default:ee},onClick:{type:Function,default:ee},intersectMode:{type:String,default:"move"},intersectRecursive:{type:Boolean,default:!1}},setup(){return{renderer:V(O)}},mounted(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer;this.renderer.onMounted(()=>{!e.camera||(this.pointer=Te({camera:e.camera,domElement:e.canvas,intersectObjects:()=>e.scene?e.scene.children:[],intersectRecursive:this.intersectRecursive,onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectClick:this.onClick}),this.pointer.addListeners(),this.intersectMode==="frame"&&e.onBeforeRender(this.pointer.intersect))})},unmounted(){var e;this.pointer&&(this.pointer.removeListeners(),(e=this.renderer)==null||e.offBeforeRender(this.pointer.intersect))},render(){return[]},__hmrId:"Raycaster"}),He=o({extends:B,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean,hideMeshes:{type:Array,default:()=>[]}},setup(e){const t=V(O);if(!t||!t.scene)return console.error("Missing Renderer / Scene"),{};const r=t.renderer,s=t.scene,i=new ds(e.cubeRTSize,{format:cs,generateMipmaps:!0,minFilter:ls}),a=new us(e.cubeCameraNear,e.cubeCameraFar,i),n=()=>{e.hideMeshes.forEach(l=>{l.visible=!1}),a.update(r,s),e.hideMeshes.forEach(l=>{l.visible=!0})};return e.autoUpdate?(t.onBeforeRender(n),Qr(()=>{t.offBeforeRender(n)})):t.onMounted(n),{cubeRT:i,cubeCamera:a,updateRT:n}},created(){this.cubeCamera&&this.initObject3D(this.cubeCamera)},render(){return[]},__hmrId:"CubeCamera"});const q=Symbol("Mesh"),H=o({name:"Mesh",extends:B,props:{castShadow:Boolean,receiveShadow:Boolean},setup(){return{}},provide(){return{[q]:this}},mounted(){!this.mesh&&!this.loading&&this.initMesh()},methods:{initMesh(){const e=new ms(this.geometry,this.material);f(this,"castShadow",e),f(this,"receiveShadow",e),this.mesh=e,this.initObject3D(e)},createGeometry(){},addGeometryWatchers(e){Object.keys(e).forEach(t=>{d(()=>this[t],()=>{this.refreshGeometry()})})},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh&&this.geometry&&(this.mesh.geometry=this.geometry),e==null||e.dispose()}},unmounted(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()},__hmrId:"Mesh"});function P(e,t,r){return o({name:e,extends:H,props:t,created(){this.createGeometry(),this.addGeometryWatchers(t)},methods:{createGeometry(){this.geometry=r(this)}}})}const de=o({props:{rotateX:Number,rotateY:Number,rotateZ:Number,attributes:{type:Array,default:()=>[]}},inject:{mesh:q},setup(){return{}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh.setGeometry(this.geometry),Object.keys(this.$props).forEach(e=>{d(()=>this[e],this.refreshGeometry)})},unmounted(){var e;(e=this.geometry)==null||e.dispose()},methods:{createGeometry(){const e={},t=new fs;this.attributes.forEach(r=>{if(r.name&&r.itemSize&&r.array){const s=e[r.name]=new ps(r.array,r.itemSize,r.normalized);t.setAttribute(r.name,s)}}),t.computeBoundingBox(),this.geometry=t},rotateGeometry(){!this.geometry||(this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ))},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh&&this.mesh.setGeometry(this.geometry),e==null||e.dispose()}},render(){return[]}});function g(e,t,r){return o({name:e,extends:de,props:t,methods:{createGeometry(){this.geometry=r(this)}}})}const Ve={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function Ke(e){return e.size?new je(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new je(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var Xe=g("BoxGeometry",Ve,Ke);const We={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ze(e){return new ys(e.radius,e.segments,e.thetaStart,e.thetaLength)}var qe=g("CircleGeometry",We,Ze);const Ye={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Je(e){return new gs(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var Qe=g("ConeGeometry",Ye,Je);const et={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function tt(e){return new vs(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var rt=g("CylinderGeometry",et,tt);const st={radius:{type:Number,default:1},detail:{type:Number,default:0}};function it(e){return new bs(e.radius,e.detail)}var nt=g("DodecahedronGeometry",st,it);const Pi={shapes:{type:[Object,Array]},options:{type:Object}};function xi(e){return new Ss(e.shapes,e.options)}var at=g("ExtrudeGeometry",Pi,xi);const ot={radius:{type:Number,default:1},detail:{type:Number,default:0}};function ht(e){return new Ps(e.radius,e.detail)}var dt=g("IcosahedronGeometry",ot,ht);const ct={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2}};function lt(e){return new xs(e.points,e.segments,e.phiStart,e.phiLength)}var ut=g("LatheGeometry",ct,lt);const mt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function ft(e){return new ws(e.radius,e.detail)}var pt=g("OctahedronGeometry",mt,ft);const yt={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function gt(e){return new ke(e.width,e.height,e.widthSegments,e.heightSegments)}var vt=g("PlaneGeometry",yt,gt);const bt={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function St(e){return new Cs(e.vertices,e.indices,e.radius,e.detail)}var Pt=g("PolyhedronGeometry",bt,St);const xt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function wt(e){return new Ms(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var Ct=g("RingGeometry",xt,wt);const Mt={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI}};function Lt(e){return new Ls(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}var Gt=g("SphereGeometry",Mt,Lt);const wi={shapes:{type:[Object,Array]},curveSegments:{type:Number}};function Ci(e){return new Gs(e.shapes,e.curveSegments)}var jt=g("ShapeGeometry",wi,Ci);const kt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function Ot(e){return new js(e.radius,e.detail)}var _t=g("TetrahedronGeometry",kt,Ot);const Nt={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:Math.PI*2}};function Et(e){return new ks(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var Rt=g("TorusGeometry",Nt,Et);const $t={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function zt(e){return new Os(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var Tt=g("TorusKnotGeometry",$t,zt);const Pe={points:Array,path:Ns,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function At(e){let t;return e.points?t=new Oe(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new _s(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var It=o({extends:de,props:Pe,methods:{createGeometry(){this.geometry=At(this)},updatePoints(e){Bt(this.geometry,e)}}});function Bt(e,t){const r=new Oe(t),{radialSegments:s,radius:i,tubularSegments:a,closed:n}=e.parameters,l=r.computeFrenetFrames(a,n);e.tangents=l.tangents,e.normals=l.normals,e.binormals=l.binormals,e.parameters.path=r;const M=e.getAttribute("position"),L=e.getAttribute("normal"),m=new ie,j=new ie;for(let v=0;v<a;v++)_(v);_(a),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0;function _(v){r.getPointAt(v/a,j);const D=l.normals[v],U=l.binormals[v];for(let p=0;p<=s;p++){const y=p/s*Math.PI*2,N=Math.sin(y),h=-Math.cos(y);m.x=h*D.x+N*U.x,m.y=h*D.y+N*U.y,m.z=h*D.z+N*U.z,m.normalize();const c=v*(s+1)+p;L.setXYZ(c,m.x,m.y,m.z),M.setXYZ(c,j.x+i*m.x,j.y+i*m.y,j.z+i*m.z)}}}var Y=o({extends:B,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:()=>({x:512,y:512})},shadowCamera:{type:Object,default:()=>({})}},setup(){return{}},unmounted(){(this.light instanceof ge||this.light instanceof ve)&&this.removeFromParent(this.light.target)},methods:{initLight(e){this.light=e,e.shadow&&(e.castShadow=this.castShadow,Z(e.shadow.mapSize,this.shadowMapSize),Z(e.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach(t=>{d(()=>this[t],r=>{t==="color"?e.color.set(r):e[t]=r})}),this.initObject3D(e),(e instanceof ge||e instanceof ve)&&(f(this,"target",e.target,"position"),this.addToParent(e.target))}},__hmrId:"Light"}),Ft=o({extends:Y,created(){this.initLight(new Es(this.color,this.intensity))},__hmrId:"AmbientLight"}),Dt=o({extends:Y,props:{target:{type:Object,default:()=>({x:0,y:0,z:0})}},created(){this.initLight(new ve(this.color,this.intensity))},__hmrId:"DirectionalLight"}),Ut=o({extends:Y,props:{groundColor:{type:String,default:"#444444"}},created(){const e=new Rs(this.color,this.groundColor,this.intensity);d(()=>this.groundColor,t=>{e.groundColor.set(t)}),this.initLight(e)},__hmrId:"HemisphereLight"}),Ht=o({extends:Y,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.initLight(new $s(this.color,this.intensity,this.distance,this.decay))},__hmrId:"PointLight"}),Vt=o({extends:Y,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){ei.init();const e=new zs(this.color,this.intensity,this.width,this.height);if(["width","height"].forEach(r=>{d(()=>this[r],s=>{e[r]=s})}),this.helper){const r=new ti(e);e.add(r)}this.initLight(e)},__hmrId:"RectAreaLight"}),Kt=o({extends:Y,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){const e=new ge(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay);["angle","decay","distance","penumbra"].forEach(r=>{d(()=>this[r],s=>{e[r]=s})}),this.initLight(e)},__hmrId:"SpotLight"});const ce=Symbol("Material"),le=o({emits:["created"],props:{color:{type:String,default:"#ffffff"},props:{type:Object,default:()=>({})}},inject:{mesh:q},setup(){return{}},provide(){return{[ce]:this}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}if(this.createMaterial){const e=this.material=this.createMaterial();d(()=>this.color,t=>{e.color.set(t)}),I(this,"props",e,!1,this.setProp),this.$emit("created",e),this.mesh.setMaterial(e)}},unmounted(){var e;(e=this.material)==null||e.dispose()},methods:{getMaterialParams(){return{...Q(this.$props,["props"]),...this.props}},setProp(e,t,r,s=!1){const i=e[t];i instanceof K?i.set(r):e[t]=r,e.needsUpdate=s},setTexture(e,t="map"){this.setProp(this.material,t,e,!0)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});function z(e,t,r){return o({name:e,extends:le,props:t,methods:{createMaterial(){return r(this.getMaterialParams())}}})}const Xt=z("BasicMaterial",{props:{type:Object,default:()=>({})}},e=>new _e(e)),Wt=z("LambertMaterial",{props:{type:Object,default:()=>({})}},e=>new Ts(e)),Zt=z("PhongMaterial",{props:{type:Object,default:()=>({})}},e=>new As(e)),qt=z("PhysicalMaterial",{props:{type:Object,default:()=>({})}},e=>new Is(e)),Yt=z("PointsMaterial",{props:{type:Object,default:()=>({})}},e=>new Bs(e)),Jt=z("ShadowMaterial",{color:{type:String,default:"#000000"},props:{type:Object,default:()=>({})}},e=>new Fs(e)),Qt=z("StandardMaterial",{props:{type:Object,default:()=>({})}},e=>new Ds(e)),er=z("ToonMaterial",{props:{type:Object,default:()=>({})}},e=>new Us(e));var tr=z("MatcapMaterial",{src:String,name:{type:String,default:"0404E8_0404B5_0404CB_3333FC"}},e=>{const t=e.src?e.src:Se(e.name),r=Q(e,["src","name"]);return r.matcap=new J().load(t),new Hs(r)});const Mi=`
  varying vec2 vUv;
  void main(){
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
  }
`,Li=`
  varying vec2 vUv;
  void main() {
    gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);
  }
`;var rr=z("ShaderMaterial",{props:{type:Object,default:()=>({uniforms:{},vertexShader:Mi,fragmentShader:Li})}},e=>new be(Q(e,["color"])));function Gi(e,t,r){return e.split(t).join(r)}const ji=X.meshphong_frag.slice(0,X.meshphong_frag.indexOf("void main() {")),ki=X.meshphong_frag.slice(X.meshphong_frag.indexOf("void main() {")),Oi={uniforms:Ne.merge([Vs.phong.uniforms,{thicknessColor:{value:new K(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`
    #define USE_UV
    ${X.meshphong_vert}
  `,fragmentShader:`
    #define USE_UV
    #define SUBSURFACE

    ${ji}

    uniform float thicknessPower;
    uniform float thicknessScale;
    uniform float thicknessDistortion;
    uniform float thicknessAmbient;
    uniform float thicknessAttenuation;
    uniform vec3 thicknessColor;

    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {
      #ifdef USE_COLOR
        vec3 thickness = vColor * thicknessColor;
      #else
        vec3 thickness = thicknessColor;
      #endif
      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));
      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
    }
  `+ki.replace("#include <lights_fragment_begin>",Gi(X.lights_fragment_begin,"RE_Direct( directLight, geometry, material, reflectedLight );",`
        RE_Direct( directLight, geometry, material, reflectedLight );
        #if defined( SUBSURFACE ) && defined( USE_UV )
          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);
        #endif
      `))};var sr=o({extends:le,props:{uniforms:{type:Object,default:()=>({diffuse:"#ffffff",thicknessColor:"#ffffff",thicknessDistortion:.4,thicknessAmbient:.01,thicknessAttenuation:.7,thicknessPower:2,thicknessScale:4})}},methods:{createMaterial(){const e=Oi,t=Ne.clone(e.uniforms);return I(this,"uniforms",t,!0,(s,i,a)=>{const n=s[i].value;n instanceof K?n.set(a):s[i].value=a}),new be({...e,lights:!0,...this.props,uniforms:t})}}}),ue=o({inject:{material:ce},props:{name:{type:String,default:"map"},uniform:String,src:String,onLoad:Function,onProgress:Function,onError:Function,props:{type:Object,default:()=>({})}},setup(){return{}},created(){this.refreshTexture(),d(()=>this.src,this.refreshTexture)},unmounted(){var e,t;(e=this.material)==null||e.setTexture(null,this.name),(t=this.texture)==null||t.dispose()},methods:{createTexture(){if(!!this.src)return new J().load(this.src,this.onLoaded,this.onProgress,this.onError)},initTexture(){!this.texture||(I(this,"props",this.texture),!!this.material&&(this.material.setTexture(this.texture,this.name),this.material.material instanceof be&&this.uniform&&(this.material.material.uniforms[this.uniform]={value:this.texture})))},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.texture=this.createTexture(),this.initTexture()},onLoaded(e){var t;(t=this.onLoad)==null||t.call(this,e)}},render(){return[]}}),ir=o({extends:ue,props:{name:{type:String,default:"envMap"},path:{type:String,required:!0},urls:{type:Array,default:()=>["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},props:{type:Object,default:()=>({mapping:Ks})}},created(){d(()=>this.path,this.refreshTexture),d(()=>this.urls,this.refreshTexture)},methods:{createTexture(){return new Xs().setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)}}}),nr=o({extends:ue,props:{videoId:{type:String,required:!0}},created(){d(()=>this.videoId,this.refreshTexture)},methods:{createTexture(){const e=document.getElementById(this.videoId);return new Ws(e)}}}),ar=P("Box",Ve,Ke),or=P("Circle",We,Ze),hr=P("Cone",Ye,Je),dr=P("Cylinder",et,tt),cr=P("Dodecahedron",st,it),lr=P("Icosahedron",ot,ht),ur=P("Lathe",ct,lt),mr=P("Octahedron",mt,ft),fr=P("Plane",yt,gt),pr=P("Polyhedron",bt,St),yr=P("Ring",xt,wt),gr=P("Sphere",Mt,Lt),vr=P("Tetrahedron",kt,Ot);const _i={text:{type:String,required:!0,default:"Text"},fontSrc:{type:String,required:!0},size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var br=o({extends:H,props:_i,setup(){return{}},created(){if(!this.fontSrc){console.error('Missing required prop: "font-src"');return}["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach(r=>{d(()=>this[r],()=>{this.font&&this.refreshGeometry()})});const t=new si;this.loading=!0,t.load(this.fontSrc,r=>{this.loading=!1,this.font=r,this.createGeometry(),this.initMesh()})},methods:{createGeometry(){this.geometry=new ri(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),this.align==="center"&&this.geometry.center()}}}),Sr=P("Torus",Nt,Et),Pr=P("TorusKnot",$t,zt),xr=o({extends:H,props:Pe,created(){this.createGeometry(),this.addGeometryWatchers(Pe)},methods:{createGeometry(){this.geometry=At(this)},updatePoints(e){Bt(this.geometry,e)}},__hmrId:"Tube"}),wr=o({emits:["loaded"],extends:H,props:{src:{type:String,required:!0},width:Number,height:Number,widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},keepSize:Boolean},setup(){return{}},created(){!this.renderer||(this.geometry=new ke(1,1,this.widthSegments,this.heightSegments),this.material=new _e({side:Zs,map:this.loadTexture()}),d(()=>this.src,this.refreshTexture),["width","height"].forEach(e=>{d(()=>this[e],this.resize)}),this.resize(),this.keepSize&&this.renderer.onResize(this.resize))},unmounted(){var e;(e=this.renderer)==null||e.offResize(this.resize)},methods:{loadTexture(){return new J().load(this.src,this.onLoaded)},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.material&&(this.material.map=this.loadTexture(),this.material.needsUpdate=!0)},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded",e)},resize(){if(!this.renderer||!this.texture)return;const e=this.renderer.size,t=this.texture.image.width,r=this.texture.image.height,s=t/r;let i=1,a=1;this.width&&this.height?(i=this.width*e.wWidth/e.width,a=this.height*e.wHeight/e.height):this.width?(i=this.width*e.wWidth/e.width,a=i/s):this.height?(a=this.height*e.wHeight/e.height,i=a*s):s>1?i=a*s:a=i/s,this.mesh&&(this.mesh.scale.x=i,this.mesh.scale.y=a)}},__hmrId:"Image"}),Cr=o({extends:H,props:{count:{type:Number,required:!0}},methods:{initMesh(){if(!!this.renderer){if(!this.geometry||!this.material)return console.error("Missing geometry and/or material"),!1;this.mesh=new ye(this.geometry,this.material,this.count),this.mesh.userData.component=this,f(this,"castShadow",this.mesh),f(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)}}},__hmrId:"InstancedMesh"}),Mr=o({extends:B,emits:["loaded"],props:{src:{type:String,required:!0}},setup(){return{}},created(){this.texture=new J().load(this.src,this.onLoaded),this.material=new qs({map:this.texture}),this.sprite=new Ys(this.material),this.initObject3D(this.sprite)},unmounted(){var e,t;(e=this.texture)==null||e.dispose(),(t=this.material)==null||t.dispose()},methods:{onLoaded(){this.updateUV(),this.$emit("loaded")},updateUV(){if(!this.texture||!this.sprite)return;const e=this.texture.image.width,t=this.texture.image.height,r=e/t;let s=.5,i=.5;r>1?s=.5*r:i=.5/r;const a=this.sprite.geometry.attributes.position.array;a[0]=-s,a[1]=-i,a[5]=s,a[6]=-i,a[10]=s,a[11]=i,a[15]=-s,a[16]=i,this.sprite.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),Lr=o({extends:B,setup(){return{}},provide(){return{[q]:this}},mounted(){this.mesh=this.points=new Js(this.geometry,this.material),this.initObject3D(this.mesh)},methods:{setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)}}}),Gr=o({extends:B,emits:["before-load","load","progress","error"],props:{src:{type:String,required:!0}},data(){return{progress:0}},methods:{onLoad(e){this.$emit("load",e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),jr=o({extends:Gr,created(){const e=new ii;this.$emit("before-load",e),e.load(this.src,t=>{this.onLoad(t),this.initObject3D(t.scene)},this.onProgress,this.onError)}}),kr=o({extends:Gr,created(){const e=new ni;this.$emit("before-load",e),e.load(this.src,t=>{this.onLoad(t),this.initObject3D(t)},this.onProgress,this.onError)}});const me=Symbol("Composer");var Or=o({setup(){return{renderer:V(O)}},provide(){return{[me]:this}},created(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer,t=new ai(this.renderer.renderer);this.composer=t,this.renderer.composer=t,e.addListener("init",()=>{e.renderer.autoClear=!1,this.resize(),e.addListener("resize",this.resize)})},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{addPass(e){var t;(t=this.composer)==null||t.addPass(e)},removePass(e){var t;(t=this.composer)==null||t.removePass(e)},resize(){this.composer&&this.renderer&&this.composer.setSize(this.renderer.size.width,this.renderer.size.height)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"EffectComposer"}),G=o({inject:{renderer:O,composer:me},emits:["ready"],setup(){return{}},created(){this.composer||console.error("Missing parent EffectComposer"),this.renderer||console.error("Missing parent Renderer")},unmounted(){var e,t,r;this.pass&&((e=this.composer)==null||e.removePass(this.pass),(r=(t=this.pass).dispose)==null||r.call(t))},methods:{initEffectPass(e){var t;this.pass=e,(t=this.composer)==null||t.addPass(e),this.$emit("ready",e)}},render(){return[]},__hmrId:"EffectPass"}),_r=o({extends:G,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new oi(this.renderer.scene,this.renderer.camera);this.initEffectPass(e)},__hmrId:"RenderPass"});const Nr={focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}};var Er=o({extends:G,props:Nr,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.renderer.size.width,height:this.renderer.size.height},t=new hi(this.renderer.scene,this.renderer.camera,e);Object.keys(Nr).forEach(r=>{d(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"BokehPass"});const Rr={noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}};var $r=o({extends:G,props:Rr,created(){const e=new di(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);Object.keys(Rr).forEach(t=>{d(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"FilmPass"}),zr=o({extends:G,created(){var e;const t=new ne(ci);(e=this.renderer)==null||e.addListener("resize",this.resize),this.initEffectPass(t)},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{resize({size:e}){if(this.pass){const{resolution:t}=this.pass.material.uniforms;t.value.x=1/e.width,t.value.y=1/e.height}}},__hmrId:"FXAAPass"});const Tr={shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}};var Ar=o({extends:G,props:Tr,created(){if(!this.renderer)return;const e=new li(this.renderer.size.width,this.renderer.size.height,{});Object.keys(Tr).forEach(t=>{e.uniforms[t].value=this[t],d(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"HalftonePass"}),Ir=o({extends:G,created(){if(!this.renderer)return;const e=new ui(this.renderer.size.width,this.renderer.size.height);this.initEffectPass(e)},__hmrId:"SMAAPass"}),Br=o({extends:G,props:{options:{type:Object,default:()=>({})}},created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new mi(this.renderer.scene,this.renderer.camera,this.renderer.size.width,this.renderer.size.height);Object.keys(this.options).forEach(t=>{e[t]=this.options[t]}),this.initEffectPass(e)},__hmrId:"SSAOPass"}),Fr={uniforms:{},vertexShader:`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,fragmentShader:`
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  `},Dr={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new A},end:{value:new A},delta:{value:new A},texSize:{value:new A}},vertexShader:Fr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float blurRadius;
    uniform float gradientRadius;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 delta;
    uniform vec2 texSize;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;

      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));
      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;
      for (float t = -30.0; t <= 30.0; t++) {
          float percent = (t + offset - 0.5) / 30.0;
          float weight = 1.0 - abs(percent);
          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);
          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);

          /* switch to pre-multiplied alpha to correctly blur transparent images */
          texel.rgb *= texel.a;
          // texel2.rgb *= texel2.a;

          color += texel * weight;
          total += 2.0 * weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `};const Ni={blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:()=>({x:0,y:100})},end:{type:Object,default:()=>({x:10,y:100})}};var Ur=o({extends:G,props:Ni,setup(){return{uniforms1:{},uniforms2:{}}},created(){if(!this.composer)return;this.pass1=new ne(Dr),this.pass2=new ne(Dr);const e=this.uniforms1=this.pass1.uniforms,t=this.uniforms2=this.pass2.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,f(this,"blurRadius",e.blurRadius,"value"),f(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach(r=>{d(()=>this[r],this.updateFocusLine,{deep:!0})}),this.pass1.setSize=(r,s)=>{e.texSize.value.set(r,s)},this.initEffectPass(this.pass1),this.composer.addPass(this.pass2)},unmounted(){this.composer&&this.pass2&&this.composer.removePass(this.pass2)},methods:{updateFocusLine(){this.uniforms1.start.value.copy(this.start),this.uniforms1.end.value.copy(this.end);const e=new A().copy(this.end).sub(this.start).normalize();this.uniforms1.delta.value.copy(e),this.uniforms2.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"});const Hr={strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}};var Vr=o({extends:G,props:Hr,created(){if(!this.renderer)return;const e=new A(this.renderer.size.width,this.renderer.size.height),t=new fi(e,this.strength,this.radius,this.threshold);Object.keys(Hr).forEach(r=>{d(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"UnrealBloomPass"}),Ei={uniforms:{tDiffuse:{value:null},center:{value:new A(.5,.5)},strength:{value:0}},vertexShader:Fr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float strength;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }
    
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      vec2 toCenter = center - vUv;
      
      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
      
      for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);

        /* switch to pre-multiplied alpha to correctly blur transparent images */
        texel.rgb *= texel.a;

        color += texel * weight;
        total += weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `},Kr=o({extends:G,props:{center:{type:Object,default:()=>({x:.5,y:.5})},strength:{type:Number,default:.5}},created(){const e=new ne(Ei);f(this,"center",e.uniforms.center,"value"),f(this,"strength",e.uniforms.strength,"value"),this.initEffectPass(e)},__hmrId:"ZoomBlurPass"}),Ri=Object.freeze({__proto__:null,Renderer:Ae,RendererInjectionKey:O,OrthographicCamera:Be,PerspectiveCamera:oe,Camera:oe,Group:De,Scene:Fe,SceneInjectionKey:he,Object3D:B,Raycaster:Ue,CubeCamera:He,BufferGeometry:de,BoxGeometry:Xe,CircleGeometry:qe,ConeGeometry:Qe,CylinderGeometry:rt,DodecahedronGeometry:nt,ExtrudeGeometry:at,IcosahedronGeometry:dt,LatheGeometry:ut,OctahedronGeometry:pt,PlaneGeometry:vt,PolyhedronGeometry:Pt,RingGeometry:Ct,SphereGeometry:Gt,ShapeGeometry:jt,TetrahedronGeometry:_t,TorusGeometry:Rt,TorusKnotGeometry:Tt,TubeGeometry:It,AmbientLight:Ft,DirectionalLight:Dt,HemisphereLight:Ut,PointLight:Ht,RectAreaLight:Vt,SpotLight:Kt,Material:le,BasicMaterial:Xt,LambertMaterial:Wt,PhongMaterial:Zt,PhysicalMaterial:qt,PointsMaterial:Yt,ShadowMaterial:Jt,StandardMaterial:Qt,ToonMaterial:er,MaterialInjectionKey:ce,MatcapMaterial:tr,ShaderMaterial:rr,SubSurfaceMaterial:sr,Texture:ue,CubeTexture:ir,VideoTexture:nr,Mesh:H,MeshInjectionKey:q,Box:ar,Circle:or,Cone:hr,Cylinder:dr,Dodecahedron:cr,Icosahedron:lr,Lathe:ur,Octahedron:mr,Plane:fr,Polyhedron:pr,Ring:yr,Sphere:gr,Tetrahedron:vr,Text:br,Torus:Sr,TorusKnot:Pr,Tube:xr,Image:wr,InstancedMesh:Cr,Sprite:Mr,Points:Lr,GltfModel:jr,FbxModel:kr,EffectComposer:Or,ComposerInjectionKey:me,RenderPass:_r,EffectPass:G,BokehPass:Er,FilmPass:$r,FXAAPass:zr,HalftonePass:Ar,SMAAPass:Ir,SSAOPass:Br,TiltShiftPass:Ur,UnrealBloomPass:Vr,ZoomBlurPass:Kr,applyObjectProps:W,bindObjectProp:I,bindObjectProps:Ee,setFromProp:Z,bindProps:Re,bindProp:f,propsValues:Q,lerp:$e,limit:ze,getMatcapUrl:Se});const Xr={install(e){["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","CubeCamera","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","PointsMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","BufferGeometry","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","PlaneGeometry","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Image","InstancedMesh","Points","Sprite","FbxModel","GltfModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass"].forEach(r=>{e.component(r,Ri[r])})}};function $i(e){return es(e).use(Xr)}function zi(){const e={loader:new J,count:0,textures:[],loadProgress:0,loadTextures:t,dispose:s};return e;function t(i,a){e.count=i.length,e.textures.splice(0),e.loadProgress=0,Promise.all(i.map(r)).then(a)}function r(i,a){return new Promise(n=>{e.loader.load(i.src,l=>{e.loadProgress+=1/e.count,e.textures[a]=l,n(l)})})}function s(){e.textures.forEach(i=>i.dispose())}}export{Ft as AmbientLight,Xt as BasicMaterial,Er as BokehPass,ar as Box,Xe as BoxGeometry,de as BufferGeometry,oe as Camera,or as Circle,qe as CircleGeometry,me as ComposerInjectionKey,hr as Cone,Qe as ConeGeometry,He as CubeCamera,ir as CubeTexture,dr as Cylinder,rt as CylinderGeometry,Dt as DirectionalLight,cr as Dodecahedron,nt as DodecahedronGeometry,Or as EffectComposer,G as EffectPass,at as ExtrudeGeometry,zr as FXAAPass,kr as FbxModel,$r as FilmPass,jr as GltfModel,De as Group,Ar as HalftonePass,Ut as HemisphereLight,lr as Icosahedron,dt as IcosahedronGeometry,wr as Image,Cr as InstancedMesh,Wt as LambertMaterial,ur as Lathe,ut as LatheGeometry,tr as MatcapMaterial,le as Material,ce as MaterialInjectionKey,H as Mesh,q as MeshInjectionKey,B as Object3D,mr as Octahedron,pt as OctahedronGeometry,Be as OrthographicCamera,oe as PerspectiveCamera,Zt as PhongMaterial,qt as PhysicalMaterial,fr as Plane,vt as PlaneGeometry,Ht as PointLight,Lr as Points,Yt as PointsMaterial,pr as Polyhedron,Pt as PolyhedronGeometry,Ue as Raycaster,Vt as RectAreaLight,_r as RenderPass,Ae as Renderer,O as RendererInjectionKey,yr as Ring,Ct as RingGeometry,Ir as SMAAPass,Br as SSAOPass,Fe as Scene,he as SceneInjectionKey,rr as ShaderMaterial,Jt as ShadowMaterial,jt as ShapeGeometry,gr as Sphere,Gt as SphereGeometry,Kt as SpotLight,Mr as Sprite,Qt as StandardMaterial,sr as SubSurfaceMaterial,vr as Tetrahedron,_t as TetrahedronGeometry,br as Text,ue as Texture,Ur as TiltShiftPass,er as ToonMaterial,Sr as Torus,Rt as TorusGeometry,Pr as TorusKnot,Tt as TorusKnotGeometry,Xr as TroisJSVuePlugin,xr as Tube,It as TubeGeometry,Vr as UnrealBloomPass,nr as VideoTexture,Kr as ZoomBlurPass,W as applyObjectProps,I as bindObjectProp,Ee as bindObjectProps,f as bindProp,Re as bindProps,$i as createApp,Se as getMatcapUrl,$e as lerp,ze as limit,Q as propsValues,Z as setFromProp,zi as useTextures};
//# sourceMappingURL=trois.module.cdn.min.js.map
