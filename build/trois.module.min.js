import{watch as d,toRef as Ge,ref as qr,defineComponent as o,inject as V,provide as Yr,getCurrentInstance as Jr,onUnmounted as Qr,createApp as es}from"vue";import{Vector3 as ie,Raycaster as ts,Plane as rs,Vector2 as k,InstancedMesh as ye,WebGLRenderer as ss,OrthographicCamera as is,PerspectiveCamera as ns,Scene as as,Color as K,Texture as os,Group as hs,WebGLCubeRenderTarget as ds,RGBFormat as ls,LinearMipmapLinearFilter as us,CubeCamera as cs,Mesh as ms,BufferGeometry as fs,BufferAttribute as ps,BoxGeometry as je,CircleGeometry as ys,ConeGeometry as gs,CylinderGeometry as vs,DodecahedronGeometry as bs,ExtrudeGeometry as Ss,IcosahedronGeometry as Ps,LatheGeometry as xs,OctahedronGeometry as ws,PlaneGeometry as Oe,PolyhedronGeometry as Cs,RingGeometry as Ms,SphereGeometry as Ls,ShapeGeometry as Gs,TetrahedronGeometry as js,TorusGeometry as Os,TorusKnotGeometry as _s,TubeGeometry as Ns,CatmullRomCurve3 as _e,Curve as Es,SpotLight as ge,DirectionalLight as ve,AmbientLight as Rs,HemisphereLight as $s,PointLight as zs,RectAreaLight as Ts,MeshLambertMaterial as As,MeshPhongMaterial as ks,MeshPhysicalMaterial as Is,PointsMaterial as Bs,ShadowMaterial as Fs,MeshStandardMaterial as Ds,MeshToonMaterial as Us,MeshBasicMaterial as Ne,TextureLoader as J,MeshMatcapMaterial as Hs,ShaderMaterial as be,ShaderChunk as X,UniformsUtils as Ee,ShaderLib as Vs,CubeReflectionMapping as Ks,CubeTextureLoader as Xs,VideoTexture as Ws,DoubleSide as Zs,SpriteMaterial as qs,Sprite as Ys,Points as Js}from"three";import{OrbitControls as Qs}from"three/examples/jsm/controls/OrbitControls.js";import{RectAreaLightUniformsLib as ei}from"three/examples/jsm/lights/RectAreaLightUniformsLib.js";import{RectAreaLightHelper as ti}from"three/examples/jsm/helpers/RectAreaLightHelper.js";import{TextGeometry as ri}from"three/examples/jsm/geometries/TextGeometry.js";import{FontLoader as si}from"three/examples/jsm/loaders/FontLoader.js";import{GLTFLoader as ii}from"three/examples/jsm/loaders/GLTFLoader.js";import{FBXLoader as ni}from"three/examples/jsm/loaders/FBXLoader.js";import{EffectComposer as ai}from"three/examples/jsm/postprocessing/EffectComposer.js";import{RenderPass as oi}from"three/examples/jsm/postprocessing/RenderPass.js";import{BokehPass as hi}from"three/examples/jsm/postprocessing/BokehPass.js";import{FilmPass as di}from"three/examples/jsm/postprocessing/FilmPass.js";import{ShaderPass as ne}from"three/examples/jsm/postprocessing/ShaderPass.js";import{FXAAShader as li}from"three/examples/jsm/shaders/FXAAShader.js";import{HalftonePass as ui}from"three/examples/jsm/postprocessing/HalftonePass.js";import{SMAAPass as ci}from"three/examples/jsm/postprocessing/SMAAPass.js";import{SSAOPass as mi}from"three/examples/jsm/postprocessing/SSAOPass.js";import{UnrealBloomPass as fi}from"three/examples/jsm/postprocessing/UnrealBloomPass.js";function W(e,t,r){t instanceof Object&&Object.entries(t).forEach(([s,i])=>{r?r(e,s,i):e[s]=i})}function I(e,t,r,s=!0,i){s&&W(r,e[t],i);const a=Ge(e,t);return d(a,n=>{W(r,n,i)})}function Re(e,t,r=!0,s){r&&W(t,e,s);const i=qr(e);return d(i,a=>{W(t,a,s)},{deep:!0})}function Z(e,t){t instanceof Object&&Object.entries(t).forEach(([r,s])=>{e[r]=s})}function $e(e,t,r){t.forEach(s=>{f(e,s,r,s)})}function f(e,t,r,s){const i=s||t,a=Ge(e,t);a.value instanceof Object?(Z(r[i],a.value),d(a,n=>{Z(r[i],n)},{deep:!0})):(a.value!==void 0&&(r[i]=e[t]),d(a,n=>{r[i]=n}))}function Q(e,t=[]){const r={};return Object.entries(e).forEach(([s,i])=>{(!t||!t.includes(s))&&(r[s]=i)}),r}function ze(e,t,r){return r=r<0?0:r,r=r>1?1:r,e+(t-e)*r}function Te(e,t,r){return e<t?t:e>r?r:e}const pi="https://rawcdn.githack.com/emmelleppi/matcaps/9b36ccaaf0a24881a39062d05566c9e92be4aa0d",yi="0404E8_0404B5_0404CB_3333FC";function Se(e=yi,t=1024){const r=`${e}${gi(t)}.png`;return`${pi}/${t}/${r}`}function gi(e){switch(e){case 64:return"-64px";case 128:return"-128px";case 256:return"-256px";case 512:return"-512px";default:return""}}function vi(e){const{camera:t,resetPosition:r=new ie(0,0,0)}=e,s=new ts,i=r.clone(),a=new rs(new ie(0,0,1),0);return{position:i,updatePosition:M=>{s.setFromCamera(M,t),t.getWorldDirection(a.normal),s.ray.intersectPlane(a,i)},intersect:(M,L,m=!1)=>(s.setFromCamera(M,t),s.intersectObjects(L,m))}}function Ae(e){const{camera:t,domElement:r,intersectObjects:s,intersectRecursive:i=!1,touch:a=!0,resetOnEnd:n=!1,onEnter:u=()=>{},onMove:M=()=>{},onLeave:L=()=>{},onClick:m=()=>{},onIntersectEnter:j=()=>{},onIntersectOver:N=()=>{},onIntersectMove:v=()=>{},onIntersectLeave:D=()=>{},onIntersectClick:U=()=>{}}=e,p=new k(0,0),y=new k(0,0),E=vi({camera:t}),h=E.position,l={position:p,positionN:y,positionV3:h,intersectObjects:s,listeners:!1,addListeners:Wr,removeListeners:Zr,intersect:xe};return l;function O(){p.set(0,0),y.set(0,0),h.set(0,0,0)}function b(c){let x,A;c.touches&&c.touches.length>0?(x=c.touches[0].clientX,A=c.touches[0].clientY):(x=c.clientX,A=c.clientY);const R=r.getBoundingClientRect();p.x=x-R.left,p.y=A-R.top,y.x=p.x/R.width*2-1,y.y=-(p.y/R.height)*2+1,E.updatePosition(y)}function xe(){const c=Ce();if(c.length){const x=E.intersect(y,c,i),A=[...c],R=[];x.forEach($=>{var F,z,S;const{object:w}=$,C=fe(w);if(w instanceof ye){if(R.indexOf(w)!==-1)return;R.push(w)}if(!w.userData.over){w.userData.over=!0;const pe={type:"pointerover",over:!0,component:C,intersect:$},Le={...pe,type:"pointerenter"};N(pe),j(Le),(F=C==null?void 0:C.onPointerOver)==null||F.call(C,pe),(z=C==null?void 0:C.onPointerEnter)==null||z.call(C,Le)}const Me={type:"pointermove",component:C,intersect:$};v(Me),(S=C==null?void 0:C.onPointerMove)==null||S.call(C,Me),A.splice(A.indexOf(w),1)}),A.forEach($=>{var F,z;const S=fe($);if($.userData.over){$.userData.over=!1;const w={type:"pointerover",over:!1,component:S},C={...w,type:"pointerleave"};N(w),D(C),(F=S==null?void 0:S.onPointerOver)==null||F.call(S,w),(z=S==null?void 0:S.onPointerLeave)==null||z.call(S,C)}})}}function te(c){b(c),u({type:"pointerenter",position:p,positionN:y,positionV3:h})}function re(c){b(c),M({type:"pointermove",position:p,positionN:y,positionV3:h}),xe()}function we(c){b(c);const x=Ce();if(x.length){const A=E.intersect(y,x,i),R=[];A.forEach($=>{var F;const{object:z}=$,S=fe(z);if(z instanceof ye){if(R.indexOf(z)!==-1)return;R.push(z)}const w={type:"click",component:S,intersect:$};U(w),(F=S==null?void 0:S.onClick)==null||F.call(S,w)})}m({type:"click",position:p,positionN:y,positionV3:h})}function se(){n&&O(),L({type:"pointerleave"})}function fe(c){if(c.userData.component)return c.userData.component;let x=c.parent;for(;x;){if(x.userData.component)return x.userData.component;x=x.parent}}function Ce(){return typeof s=="function"?s():s}function Wr(){r.addEventListener("mouseenter",te),r.addEventListener("mousemove",re),r.addEventListener("mouseleave",se),r.addEventListener("click",we),a&&(r.addEventListener("touchstart",te),r.addEventListener("touchmove",re),r.addEventListener("touchend",se)),l.listeners=!0}function Zr(){r.removeEventListener("mouseenter",te),r.removeEventListener("mousemove",re),r.removeEventListener("mouseleave",se),r.removeEventListener("click",we),r.removeEventListener("touchstart",te),r.removeEventListener("touchmove",re),r.removeEventListener("touchend",se),l.listeners=!1}}function bi(e){const t={antialias:!0,alpha:!1,autoClear:!0,orbitCtrl:!1,pointer:!1,resize:!1,width:300,height:150};e&&Object.entries(e).forEach(([h,l])=>{t[h]=l});const r={width:1,height:1,wWidth:1,wHeight:1,ratio:1},s=[],i=[],a=u(),n={config:t,renderer:a,size:r,init:M,dispose:U,render:j,renderC:N,setSize:y,addIntersectObject:v,removeIntersectObject:D};return n;function u(){const h=new ss({canvas:t.canvas,antialias:t.antialias,alpha:t.alpha,...t.params});return h.autoClear=t.autoClear,h}function M(){if(!n.scene)return console.error("Missing Scene"),!1;if(!n.camera)return console.error("Missing Camera"),!1;if(t.resize?(p(),window.addEventListener("resize",p)):t.width&&t.height&&y(t.width,t.height),L(),t.orbitCtrl){const h=new Qs(n.camera,n.renderer.domElement);t.orbitCtrl instanceof Object&&Object.entries(t.orbitCtrl).forEach(([l,O])=>{h[l]=O}),m(()=>{h.update()}),n.cameraCtrl=h}return!0}function L(){let h={camera:n.camera,domElement:n.renderer.domElement,intersectObjects:i};t.pointer&&t.pointer instanceof Object&&(h={...h,...t.pointer});const l=n.pointer=Ae(h);(t.pointer||i.length)&&(l.addListeners(),h.intersectMode==="frame"&&m(l.intersect))}function m(h){s.push(h)}function j(){s.forEach(h=>h()),n.renderer.render(n.scene,n.camera)}function N(){s.forEach(h=>h()),n.composer.render()}function v(h){i.indexOf(h)===-1&&i.push(h),n.pointer&&!n.pointer.listeners&&n.pointer.addListeners()}function D(h){const l=i.indexOf(h);l!==-1&&i.splice(l,1),n.pointer&&!t.pointer&&i.length===0&&n.pointer.removeListeners()}function U(){window.removeEventListener("resize",p),n.pointer&&n.pointer.removeListeners(),n.cameraCtrl&&n.cameraCtrl.dispose(),n.renderer&&n.renderer.dispose()}function p(){var h;if(t.resize==="window")y(window.innerWidth,window.innerHeight);else{const l=n.renderer.domElement.parentNode;l&&y(l.clientWidth,l.clientHeight)}(h=t.onResize)==null||h.call(t,r)}function y(h,l){r.width=h,r.height=l,r.ratio=h/l,n.renderer.setSize(h,l,!1);const O=n.camera;if(O.type==="PerspectiveCamera"){const b=O;b.aspect=r.ratio,b.updateProjectionMatrix()}if(O.type==="OrthographicCamera"){const b=O;r.wWidth=b.right-b.left,r.wHeight=b.top-b.bottom}else{const b=E();r.wWidth=b[0],r.wHeight=b[1]}}function E(){const h=n.camera,l=h.fov*Math.PI/180,O=2*Math.tan(l/2)*Math.abs(h.position.z);return[O*h.aspect,O]}}const _=Symbol("Renderer");var ke=o({name:"Renderer",props:{params:{type:Object,default:()=>({})},antialias:Boolean,alpha:Boolean,autoClear:{type:Boolean,default:!0},orbitCtrl:{type:[Boolean,Object],default:!1},pointer:{type:[Boolean,Object],default:!1},resize:{type:[Boolean,String],default:!1},shadow:Boolean,width:String,height:String,xr:Boolean,props:{type:Object,default:()=>({})},onReady:Function},inheritAttrs:!1,setup(e,{attrs:t}){const r=[],s=[],i=[],a=[],n=[],u=document.createElement("canvas");Object.entries(t).forEach(([j,N])=>{const v=j.match(/^on([A-Z][a-zA-Z]*)$/);v?u.addEventListener(v[1].toLowerCase(),N):u.setAttribute(j,N)});const M={canvas:u,params:e.params,antialias:e.antialias,alpha:e.alpha,autoClear:e.autoClear,orbitCtrl:e.orbitCtrl,pointer:e.pointer,resize:e.resize};e.width&&(M.width=parseInt(e.width)),e.height&&(M.height=parseInt(e.height));const L=bi(M);I(e,"props",L.renderer);const m=()=>{};return{canvas:u,three:L,renderer:L.renderer,size:L.size,renderFn:m,raf:!0,initCallbacks:r,mountedCallbacks:s,beforeRenderCallbacks:i,afterRenderCallbacks:a,resizeCallbacks:n}},computed:{camera:{get:function(){return this.three.camera},set:function(e){this.three.camera=e}},scene:{get:function(){return this.three.scene},set:function(e){this.three.scene=e}},composer:{get:function(){return this.three.composer},set:function(e){this.three.composer=e}}},provide(){return{[_]:this}},mounted(){var e;this.$el.parentNode.insertBefore(this.canvas,this.$el),this.three.init()&&(this.three.pointer&&(this.$pointer=this.three.pointer),this.three.config.onResize=t=>{this.resizeCallbacks.forEach(r=>r({type:"resize",renderer:this,size:t}))},this.shadow&&(this.renderer.shadowMap.enabled=!0),this.renderFn=this.three.composer?this.three.renderC:this.three.render,this.initCallbacks.forEach(t=>t({type:"init",renderer:this})),(e=this.onReady)==null||e.call(this,this),this.xr?(this.renderer.xr.enabled=!0,this.renderer.setAnimationLoop(this.render)):requestAnimationFrame(this.renderLoop)),this.mountedCallbacks.forEach(t=>t({type:"mounted",renderer:this}))},beforeUnmount(){this.canvas.remove(),this.beforeRenderCallbacks=[],this.afterRenderCallbacks=[],this.raf=!1,this.three.dispose()},methods:{onInit(e){this.addListener("init",e)},onMounted(e){this.addListener("mounted",e)},onBeforeRender(e){this.addListener("beforerender",e)},offBeforeRender(e){this.removeListener("beforerender",e)},onAfterRender(e){this.addListener("afterrender",e)},offAfterRender(e){this.removeListener("afterrender",e)},onResize(e){this.addListener("resize",e)},offResize(e){this.removeListener("resize",e)},addListener(e,t){this.getCallbacks(e).push(t)},removeListener(e,t){const r=this.getCallbacks(e),s=r.indexOf(t);s!==-1&&r.splice(s,1)},getCallbacks(e){return e==="init"?this.initCallbacks:e==="mounted"?this.mountedCallbacks:e==="beforerender"?this.beforeRenderCallbacks:e==="afterrender"?this.afterRenderCallbacks:this.resizeCallbacks},render(e){this.beforeRenderCallbacks.forEach(t=>t({type:"beforerender",renderer:this,time:e})),this.renderFn({renderer:this,time:e}),this.afterRenderCallbacks.forEach(t=>t({type:"afterrender",renderer:this,time:e}))},renderLoop(e){this.raf&&requestAnimationFrame(this.renderLoop),this.render(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Renderer"}),Ie=o({props:{props:{type:Object,default:()=>({})}},render(){return this.$slots.default?this.$slots.default():[]}});function ae(e,t,r,s=!0){e[t]=r,s&&e.updateProjectionMatrix()}var Be=o({extends:Ie,name:"OrthographicCamera",props:{left:{type:Number,default:-1},right:{type:Number,default:1},top:{type:Number,default:1},bottom:{type:Number,default:-1},near:{type:Number,default:.1},far:{type:Number,default:2e3},zoom:{type:Number,default:1},position:{type:Object,default:()=>({x:0,y:0,z:0})}},setup(e){const t=V(_);if(!t){console.error("Renderer not found");return}const r=new is(e.left,e.right,e.top,e.bottom,e.near,e.far);return t.camera=r,f(e,"position",r),I(e,"props",r,!0,ae),["left","right","top","bottom","near","far","zoom"].forEach(s=>{d(()=>e[s],i=>{ae(r,s,i)})}),{renderer:t,camera:r}},__hmrId:"OrthographicCamera"}),oe=o({extends:Ie,name:"PerspectiveCamera",props:{aspect:{type:Number,default:1},far:{type:Number,default:2e3},fov:{type:Number,default:50},near:{type:Number,default:.1},position:{type:Object,default:()=>({x:0,y:0,z:0})},lookAt:{type:Object,default:null}},setup(e){var t;const r=V(_);if(!r){console.error("Renderer not found");return}const s=new ns(e.fov,e.aspect,e.near,e.far);return r.camera=s,f(e,"position",s),e.lookAt&&s.lookAt((t=e.lookAt.x)!=null?t:0,e.lookAt.y,e.lookAt.z),d(()=>e.lookAt,i=>{var a;s.lookAt((a=i.x)!=null?a:0,i.y,i.z)},{deep:!0}),I(e,"props",s,!0,ae),["aspect","far","fov","near"].forEach(i=>{d(()=>e[i],a=>{ae(s,i,a)})}),{renderer:r,camera:s}},__hmrId:"PerspectiveCamera"});const he=Symbol("Scene");var Fe=o({name:"Scene",props:{background:[String,Number,Object]},setup(e){const t=V(_),r=new as;if(!t){console.error("Renderer not found");return}t.scene=r,Yr(he,r);const s=n=>{!n||(typeof n=="string"||typeof n=="number"?r.background instanceof K?r.background.set(n):r.background=new K(n):(n instanceof os||n instanceof K)&&(r.background=n))};return s(e.background),d(()=>e.background,s),{scene:r,add:n=>{r.add(n)},remove:n=>{r.remove(n)}}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Scene"});const Si={onPointerEnter:Function,onPointerOver:Function,onPointerMove:Function,onPointerLeave:Function,onPointerDown:Function,onPointerUp:Function,onClick:Function};var B=o({name:"Object3D",inject:{renderer:_,scene:he},emits:["created","ready"],props:{position:{type:Object,default:()=>({x:0,y:0,z:0})},rotation:{type:Object,default:()=>({x:0,y:0,z:0})},scale:{type:Object,default:()=>({x:1,y:1,z:1,order:"XYZ"})},lookAt:{type:Object,default:null},userData:{type:Object,default:()=>({})},visible:{type:Boolean,default:!0},props:{type:Object,default:()=>({})},disableAdd:{type:Boolean,default:!1},disableRemove:{type:Boolean,default:!1},...Si},setup(){return{}},created(){this.renderer||console.error("Missing parent Renderer"),this.scene||console.error("Missing parent Scene")},unmounted(){this.disableRemove||this.removeFromParent(),this.o3d&&this.renderer&&this.renderer.three.removeIntersectObject(this.o3d)},methods:{initObject3D(e){var t;this.o3d=e,e.userData.component=this,(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer&&this.renderer.three.addIntersectObject(e),f(this,"position",e),f(this,"rotation",e),f(this,"scale",e),f(this,"userData",e.userData),f(this,"visible",e),I(this,"props",e),this.$emit("created",e),this.lookAt&&e.lookAt((t=this.lookAt.x)!=null?t:0,this.lookAt.y,this.lookAt.z),d(()=>this.lookAt,r=>{var s;e.lookAt((s=r.x)!=null?s:0,r.y,r.z)},{deep:!0}),this.parent=this.getParent(),this.disableAdd||(this.addToParent()?this.$emit("ready",this):console.error("Missing parent (Scene, Group...)"))},getParent(){let e=this.$parent;if(!e){const t=Jr();t&&t.parent&&(e=t.parent.ctx)}for(;e;){if(e.add)return e;e=e.$parent}},addToParent(e){const t=e||this.o3d;return this.parent?(this.parent.add(t),!0):!1},removeFromParent(e){const t=e||this.o3d;return this.parent?(this.parent.remove(t),!0):!1},add(e){var t;(t=this.o3d)==null||t.add(e)},remove(e){var t;(t=this.o3d)==null||t.remove(e)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Object3D"}),De=o({name:"Group",extends:B,setup(){return{group:new hs}},created(){this.initObject3D(this.group)},__hmrId:"Group"});const ee=()=>{};var Ue=o({name:"Raycaster",props:{onPointerEnter:{type:Function,default:ee},onPointerOver:{type:Function,default:ee},onPointerMove:{type:Function,default:ee},onPointerLeave:{type:Function,default:ee},onClick:{type:Function,default:ee},intersectMode:{type:String,default:"move"},intersectRecursive:{type:Boolean,default:!1}},setup(){return{renderer:V(_)}},mounted(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer;this.renderer.onMounted(()=>{!e.camera||(this.pointer=Ae({camera:e.camera,domElement:e.canvas,intersectObjects:()=>e.scene?e.scene.children:[],intersectRecursive:this.intersectRecursive,onIntersectEnter:this.onPointerEnter,onIntersectOver:this.onPointerOver,onIntersectMove:this.onPointerMove,onIntersectLeave:this.onPointerLeave,onIntersectClick:this.onClick}),this.pointer.addListeners(),this.intersectMode==="frame"&&e.onBeforeRender(this.pointer.intersect))})},unmounted(){var e;this.pointer&&(this.pointer.removeListeners(),(e=this.renderer)==null||e.offBeforeRender(this.pointer.intersect))},render(){return[]},__hmrId:"Raycaster"}),He=o({extends:B,props:{cubeRTSize:{type:Number,default:256},cubeCameraNear:{type:Number,default:.1},cubeCameraFar:{type:Number,default:2e3},autoUpdate:Boolean,hideMeshes:{type:Array,default:()=>[]}},setup(e){const t=V(_);if(!t||!t.scene)return console.error("Missing Renderer / Scene"),{};const r=t.renderer,s=t.scene,i=new ds(e.cubeRTSize,{format:ls,generateMipmaps:!0,minFilter:us}),a=new cs(e.cubeCameraNear,e.cubeCameraFar,i),n=()=>{e.hideMeshes.forEach(u=>{u.visible=!1}),a.update(r,s),e.hideMeshes.forEach(u=>{u.visible=!0})};return e.autoUpdate?(t.onBeforeRender(n),Qr(()=>{t.offBeforeRender(n)})):t.onMounted(n),{cubeRT:i,cubeCamera:a,updateRT:n}},created(){this.cubeCamera&&this.initObject3D(this.cubeCamera)},render(){return[]},__hmrId:"CubeCamera"});const q=Symbol("Mesh"),H=o({name:"Mesh",extends:B,props:{castShadow:Boolean,receiveShadow:Boolean},setup(){return{}},provide(){return{[q]:this}},mounted(){!this.mesh&&!this.loading&&this.initMesh()},methods:{initMesh(){const e=new ms(this.geometry,this.material);f(this,"castShadow",e),f(this,"receiveShadow",e),this.mesh=e,this.initObject3D(e)},createGeometry(){},addGeometryWatchers(e){Object.keys(e).forEach(t=>{d(()=>this[t],()=>{this.refreshGeometry()})})},setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.mesh&&this.geometry&&(this.mesh.geometry=this.geometry),e==null||e.dispose()}},unmounted(){this.geometry&&this.geometry.dispose(),this.material&&this.material.dispose()},__hmrId:"Mesh"});function P(e,t,r){return o({name:e,extends:H,props:t,created(){this.createGeometry(),this.addGeometryWatchers(t)},methods:{createGeometry(){this.geometry=r(this)}}})}const de=o({props:{rotateX:Number,rotateY:Number,rotateZ:Number,attributes:{type:Array,default:()=>[]}},inject:{mesh:q},setup(){return{}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh.setGeometry(this.geometry),Object.keys(this.$props).forEach(e=>{d(()=>this[e],this.refreshGeometry)})},unmounted(){var e;(e=this.geometry)==null||e.dispose()},methods:{createGeometry(){const e={},t=new fs;this.attributes.forEach(r=>{if(r.name&&r.itemSize&&r.array){const s=e[r.name]=new ps(r.array,r.itemSize,r.normalized);t.setAttribute(r.name,s)}}),t.computeBoundingBox(),this.geometry=t},rotateGeometry(){!this.geometry||(this.rotateX&&this.geometry.rotateX(this.rotateX),this.rotateY&&this.geometry.rotateY(this.rotateY),this.rotateZ&&this.geometry.rotateZ(this.rotateZ))},refreshGeometry(){const e=this.geometry;this.createGeometry(),this.rotateGeometry(),this.geometry&&this.mesh&&this.mesh.setGeometry(this.geometry),e==null||e.dispose()}},render(){return[]}});function g(e,t,r){return o({name:e,extends:de,props:t,methods:{createGeometry(){this.geometry=r(this)}}})}const Ve={size:Number,width:{type:Number,default:1},height:{type:Number,default:1},depth:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},depthSegments:{type:Number,default:1}};function Ke(e){return e.size?new je(e.size,e.size,e.size,e.widthSegments,e.heightSegments,e.depthSegments):new je(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}var Xe=g("BoxGeometry",Ve,Ke);const We={radius:{type:Number,default:1},segments:{type:Number,default:8},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Ze(e){return new ys(e.radius,e.segments,e.thetaStart,e.thetaLength)}var qe=g("CircleGeometry",We,Ze);const Ye={radius:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function Je(e){return new gs(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var Qe=g("ConeGeometry",Ye,Je);const et={radiusTop:{type:Number,default:1},radiusBottom:{type:Number,default:1},height:{type:Number,default:1},radialSegments:{type:Number,default:8},heightSegments:{type:Number,default:1},openEnded:{type:Boolean,default:!1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function tt(e){return new vs(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}var rt=g("CylinderGeometry",et,tt);const st={radius:{type:Number,default:1},detail:{type:Number,default:0}};function it(e){return new bs(e.radius,e.detail)}var nt=g("DodecahedronGeometry",st,it);const Pi={shapes:{type:[Object,Array]},options:{type:Object}};function xi(e){return new Ss(e.shapes,e.options)}var at=g("ExtrudeGeometry",Pi,xi);const ot={radius:{type:Number,default:1},detail:{type:Number,default:0}};function ht(e){return new Ps(e.radius,e.detail)}var dt=g("IcosahedronGeometry",ot,ht);const lt={points:Array,segments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2}};function ut(e){return new xs(e.points,e.segments,e.phiStart,e.phiLength)}var ct=g("LatheGeometry",lt,ut);const mt={radius:{type:Number,default:1},detail:{type:Number,default:0}};function ft(e){return new ws(e.radius,e.detail)}var pt=g("OctahedronGeometry",mt,ft);const yt={width:{type:Number,default:1},height:{type:Number,default:1},widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1}};function gt(e){return new Oe(e.width,e.height,e.widthSegments,e.heightSegments)}var vt=g("PlaneGeometry",yt,gt);const bt={vertices:Array,indices:Array,radius:{type:Number,default:1},detail:{type:Number,default:0}};function St(e){return new Cs(e.vertices,e.indices,e.radius,e.detail)}var Pt=g("PolyhedronGeometry",bt,St);const xt={innerRadius:{type:Number,default:.5},outerRadius:{type:Number,default:1},thetaSegments:{type:Number,default:8},phiSegments:{type:Number,default:1},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI*2}};function wt(e){return new Ms(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}var Ct=g("RingGeometry",xt,wt);const Mt={radius:{type:Number,default:1},widthSegments:{type:Number,default:12},heightSegments:{type:Number,default:12},phiStart:{type:Number,default:0},phiLength:{type:Number,default:Math.PI*2},thetaStart:{type:Number,default:0},thetaLength:{type:Number,default:Math.PI}};function Lt(e){return new Ls(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}var Gt=g("SphereGeometry",Mt,Lt);const wi={shapes:{type:[Object,Array]},curveSegments:{type:Number}};function Ci(e){return new Gs(e.shapes,e.curveSegments)}var jt=g("ShapeGeometry",wi,Ci);const Ot={radius:{type:Number,default:1},detail:{type:Number,default:0}};function _t(e){return new js(e.radius,e.detail)}var Nt=g("TetrahedronGeometry",Ot,_t);const Et={radius:{type:Number,default:1},tube:{type:Number,default:.4},radialSegments:{type:Number,default:8},tubularSegments:{type:Number,default:6},arc:{type:Number,default:Math.PI*2}};function Rt(e){return new Os(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}var $t=g("TorusGeometry",Et,Rt);const zt={radius:{type:Number,default:1},tube:{type:Number,default:.4},tubularSegments:{type:Number,default:64},radialSegments:{type:Number,default:8},p:{type:Number,default:2},q:{type:Number,default:3}};function Tt(e){return new _s(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}var At=g("TorusKnotGeometry",zt,Tt);const Pe={points:Array,path:Es,tubularSegments:{type:Number,default:64},radius:{type:Number,default:1},radialSegments:{type:Number,default:8},closed:{type:Boolean,default:!1}};function kt(e){let t;return e.points?t=new _e(e.points):e.path?t=e.path:console.error("Missing path curve or points."),new Ns(t,e.tubularSegments,e.radius,e.radiusSegments,e.closed)}var It=o({extends:de,props:Pe,methods:{createGeometry(){this.geometry=kt(this)},updatePoints(e){Bt(this.geometry,e)}}});function Bt(e,t){const r=new _e(t),{radialSegments:s,radius:i,tubularSegments:a,closed:n}=e.parameters,u=r.computeFrenetFrames(a,n);e.tangents=u.tangents,e.normals=u.normals,e.binormals=u.binormals,e.parameters.path=r;const M=e.getAttribute("position"),L=e.getAttribute("normal"),m=new ie,j=new ie;for(let v=0;v<a;v++)N(v);N(a),e.attributes.position.needsUpdate=!0,e.attributes.normal.needsUpdate=!0;function N(v){r.getPointAt(v/a,j);const D=u.normals[v],U=u.binormals[v];for(let p=0;p<=s;p++){const y=p/s*Math.PI*2,E=Math.sin(y),h=-Math.cos(y);m.x=h*D.x+E*U.x,m.y=h*D.y+E*U.y,m.z=h*D.z+E*U.z,m.normalize();const l=v*(s+1)+p;L.setXYZ(l,m.x,m.y,m.z),M.setXYZ(l,j.x+i*m.x,j.y+i*m.y,j.z+i*m.z)}}}var Y=o({extends:B,name:"Light",props:{color:{type:String,default:"#ffffff"},intensity:{type:Number,default:1},castShadow:{type:Boolean,default:!1},shadowMapSize:{type:Object,default:()=>({x:512,y:512})},shadowCamera:{type:Object,default:()=>({})}},setup(){return{}},unmounted(){(this.light instanceof ge||this.light instanceof ve)&&this.removeFromParent(this.light.target)},methods:{initLight(e){this.light=e,e.shadow&&(e.castShadow=this.castShadow,Z(e.shadow.mapSize,this.shadowMapSize),Z(e.shadow.camera,this.shadowCamera)),["color","intensity","castShadow"].forEach(t=>{d(()=>this[t],r=>{t==="color"?e.color.set(r):e[t]=r})}),this.initObject3D(e),(e instanceof ge||e instanceof ve)&&(f(this,"target",e.target,"position"),this.addToParent(e.target))}},__hmrId:"Light"}),Ft=o({extends:Y,created(){this.initLight(new Rs(this.color,this.intensity))},__hmrId:"AmbientLight"}),Dt=o({extends:Y,props:{target:{type:Object,default:()=>({x:0,y:0,z:0})}},created(){this.initLight(new ve(this.color,this.intensity))},__hmrId:"DirectionalLight"}),Ut=o({extends:Y,props:{groundColor:{type:String,default:"#444444"}},created(){const e=new $s(this.color,this.groundColor,this.intensity);d(()=>this.groundColor,t=>{e.groundColor.set(t)}),this.initLight(e)},__hmrId:"HemisphereLight"}),Ht=o({extends:Y,props:{distance:{type:Number,default:0},decay:{type:Number,default:1}},created(){this.initLight(new zs(this.color,this.intensity,this.distance,this.decay))},__hmrId:"PointLight"}),Vt=o({extends:Y,props:{width:{type:Number,default:10},height:{type:Number,default:10},helper:Boolean},created(){ei.init();const e=new Ts(this.color,this.intensity,this.width,this.height);if(["width","height"].forEach(r=>{d(()=>this[r],s=>{e[r]=s})}),this.helper){const r=new ti(e);e.add(r)}this.initLight(e)},__hmrId:"RectAreaLight"}),Kt=o({extends:Y,props:{angle:{type:Number,default:Math.PI/3},decay:{type:Number,default:1},distance:{type:Number,default:0},penumbra:{type:Number,default:0},target:Object},created(){const e=new ge(this.color,this.intensity,this.distance,this.angle,this.penumbra,this.decay);["angle","decay","distance","penumbra"].forEach(r=>{d(()=>this[r],s=>{e[r]=s})}),this.initLight(e)},__hmrId:"SpotLight"});const le=Symbol("Material"),ue=o({emits:["created"],props:{color:{type:String,default:"#ffffff"},props:{type:Object,default:()=>({})}},inject:{mesh:q},setup(){return{}},provide(){return{[le]:this}},created(){if(!this.mesh){console.error("Missing parent Mesh");return}if(this.createMaterial){const e=this.material=this.createMaterial();d(()=>this.color,t=>{e.color.set(t)}),I(this,"props",e,!1,this.setProp),this.$emit("created",e),this.mesh.setMaterial(e)}},unmounted(){var e;(e=this.material)==null||e.dispose()},methods:{getMaterialParams(){return{...Q(this.$props,["props"]),...this.props}},setProp(e,t,r,s=!1){const i=e[t];i instanceof K?i.set(r):e[t]=r,e.needsUpdate=s},setTexture(e,t="map"){this.setProp(this.material,t,e,!0)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"Material"});function T(e,t,r){return o({name:e,extends:ue,props:t,methods:{createMaterial(){return r(this.getMaterialParams())}}})}const Xt=T("BasicMaterial",{props:{type:Object,default:()=>({})}},e=>new Ne(e)),Wt=T("LambertMaterial",{props:{type:Object,default:()=>({})}},e=>new As(e)),Zt=T("PhongMaterial",{props:{type:Object,default:()=>({})}},e=>new ks(e)),qt=T("PhysicalMaterial",{props:{type:Object,default:()=>({})}},e=>new Is(e)),Yt=T("PointsMaterial",{props:{type:Object,default:()=>({})}},e=>new Bs(e)),Jt=T("ShadowMaterial",{color:{type:String,default:"#000000"},props:{type:Object,default:()=>({})}},e=>new Fs(e)),Qt=T("StandardMaterial",{props:{type:Object,default:()=>({})}},e=>new Ds(e)),er=T("ToonMaterial",{props:{type:Object,default:()=>({})}},e=>new Us(e));var tr=T("MatcapMaterial",{src:String,name:{type:String,default:"0404E8_0404B5_0404CB_3333FC"}},e=>{const t=e.src?e.src:Se(e.name),r=Q(e,["src","name"]);return r.matcap=new J().load(t),new Hs(r)});const Mi=`
  varying vec2 vUv;
  void main(){
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
  }
`,Li=`
  varying vec2 vUv;
  void main() {
    gl_FragColor = vec4(vUv.x, vUv.y, 0., 1.0);
  }
`;var rr=T("ShaderMaterial",{props:{type:Object,default:()=>({uniforms:{},vertexShader:Mi,fragmentShader:Li})}},e=>new be(Q(e,["color"])));function Gi(e,t,r){return e.split(t).join(r)}const ji=X.meshphong_frag.slice(0,X.meshphong_frag.indexOf("void main() {")),Oi=X.meshphong_frag.slice(X.meshphong_frag.indexOf("void main() {")),_i={uniforms:Ee.merge([Vs.phong.uniforms,{thicknessColor:{value:new K(16777215)},thicknessDistortion:{value:.1},thicknessAmbient:{value:0},thicknessAttenuation:{value:.1},thicknessPower:{value:2},thicknessScale:{value:10}}]),vertexShader:`
    #define USE_UV
    ${X.meshphong_vert}
  `,fragmentShader:`
    #define USE_UV
    #define SUBSURFACE

    ${ji}

    uniform float thicknessPower;
    uniform float thicknessScale;
    uniform float thicknessDistortion;
    uniform float thicknessAmbient;
    uniform float thicknessAttenuation;
    uniform vec3 thicknessColor;

    void RE_Direct_Scattering(const in IncidentLight directLight, const in vec2 uv, const in GeometricContext geometry, inout ReflectedLight reflectedLight) {
      #ifdef USE_COLOR
        vec3 thickness = vColor * thicknessColor;
      #else
        vec3 thickness = thicknessColor;
      #endif
      vec3 scatteringHalf = normalize(directLight.direction + (geometry.normal * thicknessDistortion));
      float scatteringDot = pow(saturate(dot(geometry.viewDir, -scatteringHalf)), thicknessPower) * thicknessScale;
      vec3 scatteringIllu = (scatteringDot + thicknessAmbient) * thickness;
      reflectedLight.directDiffuse += scatteringIllu * thicknessAttenuation * directLight.color;
    }
  `+Oi.replace("#include <lights_fragment_begin>",Gi(X.lights_fragment_begin,"RE_Direct( directLight, geometry, material, reflectedLight );",`
        RE_Direct( directLight, geometry, material, reflectedLight );
        #if defined( SUBSURFACE ) && defined( USE_UV )
          RE_Direct_Scattering(directLight, vUv, geometry, reflectedLight);
        #endif
      `))};var sr=o({extends:ue,props:{uniforms:{type:Object,default:()=>({diffuse:"#ffffff",thicknessColor:"#ffffff",thicknessDistortion:.4,thicknessAmbient:.01,thicknessAttenuation:.7,thicknessPower:2,thicknessScale:4})}},methods:{createMaterial(){const e=_i,t=Ee.clone(e.uniforms);return I(this,"uniforms",t,!0,(s,i,a)=>{const n=s[i].value;n instanceof K?n.set(a):s[i].value=a}),new be({...e,lights:!0,...this.props,uniforms:t})}}}),ce=o({inject:{material:le},props:{name:{type:String,default:"map"},uniform:String,src:String,onLoad:Function,onProgress:Function,onError:Function,props:{type:Object,default:()=>({})}},setup(){return{}},created(){this.refreshTexture(),d(()=>this.src,this.refreshTexture)},unmounted(){var e,t;(e=this.material)==null||e.setTexture(null,this.name),(t=this.texture)==null||t.dispose()},methods:{createTexture(){if(!!this.src)return new J().load(this.src,this.onLoaded,this.onProgress,this.onError)},initTexture(){!this.texture||(I(this,"props",this.texture),!!this.material&&(this.material.setTexture(this.texture,this.name),this.material.material instanceof be&&this.uniform&&(this.material.material.uniforms[this.uniform]={value:this.texture})))},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.texture=this.createTexture(),this.initTexture()},onLoaded(e){var t;(t=this.onLoad)==null||t.call(this,e)}},render(){return[]}}),ir=o({extends:ce,props:{name:{type:String,default:"envMap"},path:{type:String,required:!0},urls:{type:Array,default:()=>["px.jpg","nx.jpg","py.jpg","ny.jpg","pz.jpg","nz.jpg"]},props:{type:Object,default:()=>({mapping:Ks})}},created(){d(()=>this.path,this.refreshTexture),d(()=>this.urls,this.refreshTexture)},methods:{createTexture(){return new Xs().setPath(this.path).load(this.urls,this.onLoaded,this.onProgress,this.onError)}}}),nr=o({extends:ce,props:{videoId:{type:String,required:!0}},created(){d(()=>this.videoId,this.refreshTexture)},methods:{createTexture(){const e=document.getElementById(this.videoId);return new Ws(e)}}}),ar=P("Box",Ve,Ke),or=P("Circle",We,Ze),hr=P("Cone",Ye,Je),dr=P("Cylinder",et,tt),lr=P("Dodecahedron",st,it),ur=P("Icosahedron",ot,ht),cr=P("Lathe",lt,ut),mr=P("Octahedron",mt,ft),fr=P("Plane",yt,gt),pr=P("Polyhedron",bt,St),yr=P("Ring",xt,wt),gr=P("Sphere",Mt,Lt),vr=P("Tetrahedron",Ot,_t);const Ni={text:{type:String,required:!0,default:"Text"},fontSrc:{type:String,required:!0},size:{type:Number,default:80},height:{type:Number,default:5},depth:{type:Number,default:1},curveSegments:{type:Number,default:12},bevelEnabled:{type:Boolean,default:!1},bevelThickness:{type:Number,default:10},bevelSize:{type:Number,default:8},bevelOffset:{type:Number,default:0},bevelSegments:{type:Number,default:5},align:{type:[Boolean,String],default:!1}};var br=o({extends:H,props:Ni,setup(){return{}},created(){if(!this.fontSrc){console.error('Missing required prop: "font-src"');return}["text","size","height","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","align"].forEach(r=>{d(()=>this[r],()=>{this.font&&this.refreshGeometry()})});const t=new si;this.loading=!0,t.load(this.fontSrc,r=>{this.loading=!1,this.font=r,this.createGeometry(),this.initMesh()})},methods:{createGeometry(){this.geometry=new ri(this.text,{font:this.font,size:this.size,height:this.height,depth:this.depth,curveSegments:this.curveSegments,bevelEnabled:this.bevelEnabled,bevelThickness:this.bevelThickness,bevelSize:this.bevelSize,bevelOffset:this.bevelOffset,bevelSegments:this.bevelSegments}),this.align==="center"&&this.geometry.center()}}}),Sr=P("Torus",Et,Rt),Pr=P("TorusKnot",zt,Tt),xr=o({extends:H,props:Pe,created(){this.createGeometry(),this.addGeometryWatchers(Pe)},methods:{createGeometry(){this.geometry=kt(this)},updatePoints(e){Bt(this.geometry,e)}},__hmrId:"Tube"}),wr=o({emits:["loaded"],extends:H,props:{src:{type:String,required:!0},width:Number,height:Number,widthSegments:{type:Number,default:1},heightSegments:{type:Number,default:1},keepSize:Boolean},setup(){return{}},created(){!this.renderer||(this.geometry=new Oe(1,1,this.widthSegments,this.heightSegments),this.material=new Ne({side:Zs,map:this.loadTexture()}),d(()=>this.src,this.refreshTexture),["width","height"].forEach(e=>{d(()=>this[e],this.resize)}),this.resize(),this.keepSize&&this.renderer.onResize(this.resize))},unmounted(){var e;(e=this.renderer)==null||e.offResize(this.resize)},methods:{loadTexture(){return new J().load(this.src,this.onLoaded)},refreshTexture(){var e;(e=this.texture)==null||e.dispose(),this.material&&(this.material.map=this.loadTexture(),this.material.needsUpdate=!0)},onLoaded(e){this.texture=e,this.resize(),this.$emit("loaded",e)},resize(){if(!this.renderer||!this.texture)return;const e=this.renderer.size,t=this.texture.image.width,r=this.texture.image.height,s=t/r;let i=1,a=1;this.width&&this.height?(i=this.width*e.wWidth/e.width,a=this.height*e.wHeight/e.height):this.width?(i=this.width*e.wWidth/e.width,a=i/s):this.height?(a=this.height*e.wHeight/e.height,i=a*s):s>1?i=a*s:a=i/s,this.mesh&&(this.mesh.scale.x=i,this.mesh.scale.y=a)}},__hmrId:"Image"}),Cr=o({extends:H,props:{count:{type:Number,required:!0}},methods:{initMesh(){if(!!this.renderer){if(!this.geometry||!this.material)return console.error("Missing geometry and/or material"),!1;this.mesh=new ye(this.geometry,this.material,this.count),this.mesh.userData.component=this,f(this,"castShadow",this.mesh),f(this,"receiveShadow",this.mesh),(this.onPointerEnter||this.onPointerOver||this.onPointerMove||this.onPointerLeave||this.onPointerDown||this.onPointerUp||this.onClick)&&this.renderer.three.addIntersectObject(this.mesh),this.initObject3D(this.mesh)}}},__hmrId:"InstancedMesh"}),Mr=o({extends:B,emits:["loaded"],props:{src:{type:String,required:!0}},setup(){return{}},created(){this.texture=new J().load(this.src,this.onLoaded),this.material=new qs({map:this.texture}),this.sprite=new Ys(this.material),this.initObject3D(this.sprite)},unmounted(){var e,t;(e=this.texture)==null||e.dispose(),(t=this.material)==null||t.dispose()},methods:{onLoaded(){this.updateUV(),this.$emit("loaded")},updateUV(){if(!this.texture||!this.sprite)return;const e=this.texture.image.width,t=this.texture.image.height,r=e/t;let s=.5,i=.5;r>1?s=.5*r:i=.5/r;const a=this.sprite.geometry.attributes.position.array;a[0]=-s,a[1]=-i,a[5]=s,a[6]=-i,a[10]=s,a[11]=i,a[15]=-s,a[16]=i,this.sprite.geometry.attributes.position.needsUpdate=!0}},__hmrId:"Sprite"}),Lr=o({extends:B,setup(){return{}},provide(){return{[q]:this}},mounted(){this.mesh=this.points=new Js(this.geometry,this.material),this.initObject3D(this.mesh)},methods:{setGeometry(e){this.geometry=e,this.mesh&&(this.mesh.geometry=e)},setMaterial(e){this.material=e,this.mesh&&(this.mesh.material=e)}}}),Gr=o({extends:B,emits:["before-load","load","progress","error"],props:{src:{type:String,required:!0}},data(){return{progress:0}},methods:{onLoad(e){this.$emit("load",e)},onProgress(e){this.progress=e.loaded/e.total,this.$emit("progress",e)},onError(e){this.$emit("error",e)}}}),jr=o({extends:Gr,created(){const e=new ii;this.$emit("before-load",e),e.load(this.src,t=>{this.onLoad(t),this.initObject3D(t.scene)},this.onProgress,this.onError)}}),Or=o({extends:Gr,created(){const e=new ni;this.$emit("before-load",e),e.load(this.src,t=>{this.onLoad(t),this.initObject3D(t)},this.onProgress,this.onError)}});const me=Symbol("Composer");var _r=o({setup(){return{renderer:V(_)}},provide(){return{[me]:this}},created(){if(!this.renderer){console.error("Renderer not found");return}const e=this.renderer,t=new ai(this.renderer.renderer);this.composer=t,this.renderer.composer=t,e.addListener("init",()=>{e.renderer.autoClear=!1,this.resize(),e.addListener("resize",this.resize)})},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{addPass(e){var t;(t=this.composer)==null||t.addPass(e)},removePass(e){var t;(t=this.composer)==null||t.removePass(e)},resize(){this.composer&&this.renderer&&this.composer.setSize(this.renderer.size.width,this.renderer.size.height)}},render(){return this.$slots.default?this.$slots.default():[]},__hmrId:"EffectComposer"}),G=o({inject:{renderer:_,composer:me},emits:["ready"],setup(){return{}},created(){this.composer||console.error("Missing parent EffectComposer"),this.renderer||console.error("Missing parent Renderer")},unmounted(){var e,t,r;this.pass&&((e=this.composer)==null||e.removePass(this.pass),(r=(t=this.pass).dispose)==null||r.call(t))},methods:{initEffectPass(e){var t;this.pass=e,(t=this.composer)==null||t.addPass(e),this.$emit("ready",e)}},render(){return[]},__hmrId:"EffectPass"}),Nr=o({extends:G,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new oi(this.renderer.scene,this.renderer.camera);this.initEffectPass(e)},__hmrId:"RenderPass"});const Er={focus:{type:Number,default:1},aperture:{type:Number,default:.025},maxblur:{type:Number,default:.01}};var Rr=o({extends:G,props:Er,created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e={focus:this.focus,aperture:this.aperture,maxblur:this.maxblur,width:this.renderer.size.width,height:this.renderer.size.height},t=new hi(this.renderer.scene,this.renderer.camera,e);Object.keys(Er).forEach(r=>{d(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"BokehPass"});const $r={noiseIntensity:{type:Number,default:.5},scanlinesIntensity:{type:Number,default:.05},scanlinesCount:{type:Number,default:4096},grayscale:{type:Number,default:0}};var zr=o({extends:G,props:$r,created(){const e=new di(this.noiseIntensity,this.scanlinesIntensity,this.scanlinesCount,this.grayscale);Object.keys($r).forEach(t=>{d(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"FilmPass"}),Tr=o({extends:G,created(){var e;const t=new ne(li);(e=this.renderer)==null||e.addListener("resize",this.resize),this.initEffectPass(t)},unmounted(){var e;(e=this.renderer)==null||e.removeListener("resize",this.resize)},methods:{resize({size:e}){if(this.pass){const{resolution:t}=this.pass.material.uniforms;t.value.x=1/e.width,t.value.y=1/e.height}}},__hmrId:"FXAAPass"});const Ar={shape:{type:Number,default:1},radius:{type:Number,default:4},rotateR:{type:Number,default:Math.PI/12*1},rotateG:{type:Number,default:Math.PI/12*2},rotateB:{type:Number,default:Math.PI/12*3},scatter:{type:Number,default:0}};var kr=o({extends:G,props:Ar,created(){if(!this.renderer)return;const e=new ui(this.renderer.size.width,this.renderer.size.height,{});Object.keys(Ar).forEach(t=>{e.uniforms[t].value=this[t],d(()=>this[t],r=>{e.uniforms[t].value=r})}),this.initEffectPass(e)},__hmrId:"HalftonePass"}),Ir=o({extends:G,created(){if(!this.renderer)return;const e=new ci(this.renderer.size.width,this.renderer.size.height);this.initEffectPass(e)},__hmrId:"SMAAPass"}),Br=o({extends:G,props:{options:{type:Object,default:()=>({})}},created(){if(!this.renderer)return;if(!this.renderer.scene){console.error("Missing Scene");return}if(!this.renderer.camera){console.error("Missing Camera");return}const e=new mi(this.renderer.scene,this.renderer.camera,this.renderer.size.width,this.renderer.size.height);Object.keys(this.options).forEach(t=>{e[t]=this.options[t]}),this.initEffectPass(e)},__hmrId:"SSAOPass"}),Fr={uniforms:{},vertexShader:`
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,fragmentShader:`
    varying vec2 vUv;
    void main() {
      gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
    }
  `},Dr={uniforms:{tDiffuse:{value:null},blurRadius:{value:0},gradientRadius:{value:0},start:{value:new k},end:{value:new k},delta:{value:new k},texSize:{value:new k}},vertexShader:Fr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float blurRadius;
    uniform float gradientRadius;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 delta;
    uniform vec2 texSize;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;

      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);

      vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));
      float radius = smoothstep(0.0, 1.0, abs(dot(vUv * texSize - start, normal)) / gradientRadius) * blurRadius;
      for (float t = -30.0; t <= 30.0; t++) {
          float percent = (t + offset - 0.5) / 30.0;
          float weight = 1.0 - abs(percent);
          vec4 texel = texture2D(tDiffuse, vUv + delta / texSize * percent * radius);
          // vec4 texel2 = texture2D(tDiffuse, vUv + vec2(-delta.y, delta.x) / texSize * percent * radius);

          /* switch to pre-multiplied alpha to correctly blur transparent images */
          texel.rgb *= texel.a;
          // texel2.rgb *= texel2.a;

          color += texel * weight;
          total += 2.0 * weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `};const Ei={blurRadius:{type:Number,default:10},gradientRadius:{type:Number,default:100},start:{type:Object,default:()=>({x:0,y:100})},end:{type:Object,default:()=>({x:10,y:100})}};var Ur=o({extends:G,props:Ei,setup(){return{uniforms1:{},uniforms2:{}}},created(){if(!this.composer)return;this.pass1=new ne(Dr),this.pass2=new ne(Dr);const e=this.uniforms1=this.pass1.uniforms,t=this.uniforms2=this.pass2.uniforms;t.blurRadius=e.blurRadius,t.gradientRadius=e.gradientRadius,t.start=e.start,t.end=e.end,t.texSize=e.texSize,f(this,"blurRadius",e.blurRadius,"value"),f(this,"gradientRadius",e.gradientRadius,"value"),this.updateFocusLine(),["start","end"].forEach(r=>{d(()=>this[r],this.updateFocusLine,{deep:!0})}),this.pass1.setSize=(r,s)=>{e.texSize.value.set(r,s)},this.initEffectPass(this.pass1),this.composer.addPass(this.pass2)},unmounted(){this.composer&&this.pass2&&this.composer.removePass(this.pass2)},methods:{updateFocusLine(){this.uniforms1.start.value.copy(this.start),this.uniforms1.end.value.copy(this.end);const e=new k().copy(this.end).sub(this.start).normalize();this.uniforms1.delta.value.copy(e),this.uniforms2.delta.value.set(-e.y,e.x)}},__hmrId:"TiltShiftPass"});const Hr={strength:{type:Number,default:1.5},radius:{type:Number,default:0},threshold:{type:Number,default:0}};var Vr=o({extends:G,props:Hr,created(){if(!this.renderer)return;const e=new k(this.renderer.size.width,this.renderer.size.height),t=new fi(e,this.strength,this.radius,this.threshold);Object.keys(Hr).forEach(r=>{d(()=>this[r],s=>{t.uniforms[r].value=s})}),this.initEffectPass(t)},__hmrId:"UnrealBloomPass"}),Ri={uniforms:{tDiffuse:{value:null},center:{value:new k(.5,.5)},strength:{value:0}},vertexShader:Fr.vertexShader,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform vec2 center;
    uniform float strength;
    varying vec2 vUv;

    float random(vec3 scale, float seed) {
      /* use the fragment position for a different seed per-pixel */
      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }
    
    void main() {
      vec4 color = vec4(0.0);
      float total = 0.0;
      vec2 toCenter = center - vUv;
      
      /* randomize the lookup values to hide the fixed number of samples */
      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
      
      for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);

        /* switch to pre-multiplied alpha to correctly blur transparent images */
        texel.rgb *= texel.a;

        color += texel * weight;
        total += weight;
      }

      gl_FragColor = color / total;

      /* switch back from pre-multiplied alpha */
      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;
    }
  `},Kr=o({extends:G,props:{center:{type:Object,default:()=>({x:.5,y:.5})},strength:{type:Number,default:.5}},created(){const e=new ne(Ri);f(this,"center",e.uniforms.center,"value"),f(this,"strength",e.uniforms.strength,"value"),this.initEffectPass(e)},__hmrId:"ZoomBlurPass"}),$i=Object.freeze({__proto__:null,Renderer:ke,RendererInjectionKey:_,OrthographicCamera:Be,PerspectiveCamera:oe,Camera:oe,Group:De,Scene:Fe,SceneInjectionKey:he,Object3D:B,Raycaster:Ue,CubeCamera:He,BufferGeometry:de,BoxGeometry:Xe,CircleGeometry:qe,ConeGeometry:Qe,CylinderGeometry:rt,DodecahedronGeometry:nt,ExtrudeGeometry:at,IcosahedronGeometry:dt,LatheGeometry:ct,OctahedronGeometry:pt,PlaneGeometry:vt,PolyhedronGeometry:Pt,RingGeometry:Ct,SphereGeometry:Gt,ShapeGeometry:jt,TetrahedronGeometry:Nt,TorusGeometry:$t,TorusKnotGeometry:At,TubeGeometry:It,AmbientLight:Ft,DirectionalLight:Dt,HemisphereLight:Ut,PointLight:Ht,RectAreaLight:Vt,SpotLight:Kt,Material:ue,BasicMaterial:Xt,LambertMaterial:Wt,PhongMaterial:Zt,PhysicalMaterial:qt,PointsMaterial:Yt,ShadowMaterial:Jt,StandardMaterial:Qt,ToonMaterial:er,MaterialInjectionKey:le,MatcapMaterial:tr,ShaderMaterial:rr,SubSurfaceMaterial:sr,Texture:ce,CubeTexture:ir,VideoTexture:nr,Mesh:H,MeshInjectionKey:q,Box:ar,Circle:or,Cone:hr,Cylinder:dr,Dodecahedron:lr,Icosahedron:ur,Lathe:cr,Octahedron:mr,Plane:fr,Polyhedron:pr,Ring:yr,Sphere:gr,Tetrahedron:vr,Text:br,Torus:Sr,TorusKnot:Pr,Tube:xr,Image:wr,InstancedMesh:Cr,Sprite:Mr,Points:Lr,GltfModel:jr,FbxModel:Or,EffectComposer:_r,ComposerInjectionKey:me,RenderPass:Nr,EffectPass:G,BokehPass:Rr,FilmPass:zr,FXAAPass:Tr,HalftonePass:kr,SMAAPass:Ir,SSAOPass:Br,TiltShiftPass:Ur,UnrealBloomPass:Vr,ZoomBlurPass:Kr,applyObjectProps:W,bindObjectProp:I,bindObjectProps:Re,setFromProp:Z,bindProps:$e,bindProp:f,propsValues:Q,lerp:ze,limit:Te,getMatcapUrl:Se});const Xr={install(e){["Camera","OrthographicCamera","PerspectiveCamera","Raycaster","Renderer","Scene","Group","CubeCamera","AmbientLight","DirectionalLight","HemisphereLight","PointLight","RectAreaLight","SpotLight","BasicMaterial","LambertMaterial","MatcapMaterial","PhongMaterial","PhysicalMaterial","PointsMaterial","ShaderMaterial","StandardMaterial","SubSurfaceMaterial","ToonMaterial","Texture","CubeTexture","BufferGeometry","Mesh","Box","BoxGeometry","Circle","CircleGeometry","Cone","ConeGeometry","Cylinder","CylinderGeometry","Dodecahedron","DodecahedronGeometry","Icosahedron","IcosahedronGeometry","Lathe","LatheGeometry","Octahedron","OctahedronGeometry","Plane","PlaneGeometry","Polyhedron","PolyhedronGeometry","Ring","RingGeometry","Sphere","SphereGeometry","Tetrahedron","TetrahedronGeometry","Text","Torus","TorusGeometry","TorusKnot","TorusKnotGeometry","Tube","TubeGeometry","Image","InstancedMesh","Points","Sprite","FbxModel","GltfModel","BokehPass","EffectComposer","FilmPass","FXAAPass","HalftonePass","RenderPass","SAOPass","SMAAPass","SSAOPass","TiltShiftPass","UnrealBloomPass","ZoomBlurPass"].forEach(r=>{e.component(r,$i[r])})}};function zi(e){return es(e).use(Xr)}function Ti(){const e={loader:new J,count:0,textures:[],loadProgress:0,loadTextures:t,dispose:s};return e;function t(i,a){e.count=i.length,e.textures.splice(0),e.loadProgress=0,Promise.all(i.map(r)).then(a)}function r(i,a){return new Promise(n=>{e.loader.load(i.src,u=>{e.loadProgress+=1/e.count,e.textures[a]=u,n(u)})})}function s(){e.textures.forEach(i=>i.dispose())}}export{Ft as AmbientLight,Xt as BasicMaterial,Rr as BokehPass,ar as Box,Xe as BoxGeometry,de as BufferGeometry,oe as Camera,or as Circle,qe as CircleGeometry,me as ComposerInjectionKey,hr as Cone,Qe as ConeGeometry,He as CubeCamera,ir as CubeTexture,dr as Cylinder,rt as CylinderGeometry,Dt as DirectionalLight,lr as Dodecahedron,nt as DodecahedronGeometry,_r as EffectComposer,G as EffectPass,at as ExtrudeGeometry,Tr as FXAAPass,Or as FbxModel,zr as FilmPass,jr as GltfModel,De as Group,kr as HalftonePass,Ut as HemisphereLight,ur as Icosahedron,dt as IcosahedronGeometry,wr as Image,Cr as InstancedMesh,Wt as LambertMaterial,cr as Lathe,ct as LatheGeometry,tr as MatcapMaterial,ue as Material,le as MaterialInjectionKey,H as Mesh,q as MeshInjectionKey,B as Object3D,mr as Octahedron,pt as OctahedronGeometry,Be as OrthographicCamera,oe as PerspectiveCamera,Zt as PhongMaterial,qt as PhysicalMaterial,fr as Plane,vt as PlaneGeometry,Ht as PointLight,Lr as Points,Yt as PointsMaterial,pr as Polyhedron,Pt as PolyhedronGeometry,Ue as Raycaster,Vt as RectAreaLight,Nr as RenderPass,ke as Renderer,_ as RendererInjectionKey,yr as Ring,Ct as RingGeometry,Ir as SMAAPass,Br as SSAOPass,Fe as Scene,he as SceneInjectionKey,rr as ShaderMaterial,Jt as ShadowMaterial,jt as ShapeGeometry,gr as Sphere,Gt as SphereGeometry,Kt as SpotLight,Mr as Sprite,Qt as StandardMaterial,sr as SubSurfaceMaterial,vr as Tetrahedron,Nt as TetrahedronGeometry,br as Text,ce as Texture,Ur as TiltShiftPass,er as ToonMaterial,Sr as Torus,$t as TorusGeometry,Pr as TorusKnot,At as TorusKnotGeometry,Xr as TroisJSVuePlugin,xr as Tube,It as TubeGeometry,Vr as UnrealBloomPass,nr as VideoTexture,Kr as ZoomBlurPass,W as applyObjectProps,I as bindObjectProp,Re as bindObjectProps,f as bindProp,$e as bindProps,zi as createApp,Se as getMatcapUrl,ze as lerp,Te as limit,Q as propsValues,Z as setFromProp,Ti as useTextures};
//# sourceMappingURL=trois.module.min.js.map
